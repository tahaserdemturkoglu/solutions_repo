{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics 2332","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics 2332","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Theoretical Foundation Derivation of Governing Equations of Motion Projectile motion is governed by Newton's Second Law: \\(F=ma\\) In the absence of air resistance, the only force acting on a projectile is gravity. Assuming motion in two dimensions (horizontal \\(x\\) and vertical \\(y\\) ), we express the acceleration components as: \\(a_x=0,\\quad a_y=-g\\) where \\(g\\) is the acceleration due to gravity. Using kinematic equations: \\(v=v_0+at\\) \\(s=s_0+v_0t+\\frac{1}{2}at^2\\) For horizontal motion: \\(v_x=v_0\\cos\\theta\\) \\(x=v_0\\cos\\theta\\cdot t\\) For vertical motion: \\(v_y=v_0\\sin\\theta-gt\\) \\(y=v_0\\sin\\theta\\cdot t-\\frac{1}{2}gt^2\\) where: - \\(v_0\\) is the initial velocity, - \\(\\theta\\) is the launch angle, - \\(t\\) is time. Solving the Basic Differential Equations The motion of the projectile can also be described using differential equations: \\[\\frac{d^2x}{dt^2}=0,\\quad\\frac{d^2y}{dt^2}=-g\\] Integrating both equations: \\[\\frac{dx}{dt}=v_0\\cos\\theta\\] \\[\\frac{dy}{dt}=v_0\\sin\\theta-gt\\] A second integration gives the position equations: \\[x(t)=v_0\\cos\\theta\\cdot t\\] \\[y(t)=v_0\\sin\\theta\\cdot t-\\frac{1}{2}gt^2\\] Effect of Initial Conditions on Trajectory Time of Flight Setting \\(y=0\\) to find the total flight time: \\[v_0\\sin\\theta\\cdot t-\\frac{1}{2}gt^2=0\\] Solving for \\(t\\) : \\[t=\\frac{2v_0\\sin\\theta}{g}\\] Maximum Height At the peak of the motion, \\(v_y=0\\) : \\[0=v_0\\sin\\theta-gt_{max}\\] Solving for \\(t_{max}\\) : \\[t_{max}=\\frac{v_0\\sin\\theta}{g}\\] Substituting into the vertical position equation: \\[H=\\frac{(v_0\\sin\\theta)^2}{2g}\\] Range of the Projectile The range \\(R\\) is given by: \\[R=v_0\\cos\\theta\\cdot t_{total}\\] Substituting \\(t_{total}=\\frac{2v_0\\sin\\theta}{g}\\) : \\[R=\\frac{v_0^2\\sin2\\theta}{g}\\] Observations The range is maximized at \\(\\theta=45^\\circ\\) . Doubling the initial velocity quadruples the range. Increasing \\(g\\) decreases the range. These equations provide a foundation for further analysis, including air resistance and varying gravitational fields. Analysis of the Range Dependence of Range on Angle of Projection The range \\(R\\) of a projectile launched with an initial velocity \\(v_0\\) at an angle \\(heta\\) from the horizontal is given by the equation: \\[R = \\frac{v_0^2 \\sin 2\\theta}{g}\\] where: - \\(v_0\\) is the initial velocity, - \\(heta\\) is the angle of projection, - \\(g\\) is the acceleration due to gravity. Analysis: The range \\(R\\) is maximized when \\(\\sin 2 heta = 1\\) , which occurs at \\(2 heta = 90^\\circ\\) , or \\(heta = 45^\\circ\\) . For angles \\(heta > 45^\\circ\\) or \\(heta < 45^\\circ\\) , the range decreases. The function \\(\\sin 2 heta\\) is symmetric about \\(45^\\circ\\) , meaning that angles \\(heta\\) and \\(90^\\circ - heta\\) produce the same range. Effect of Initial Velocity and Gravitational Acceleration on Range Since the range equation is: \\[R = \\frac{v_0^2 \\sin 2\\theta}{g},\\] we can analyze the influence of \\(v_0\\) and \\(g\\) : Effect of Initial Velocity \\(v_0\\) : \\[\\frac{dR}{dv_0} = \\frac{2 v_0 \\sin 2\\theta}{g} > 0\\] The range \\(R\\) increases quadratically with \\(v_0\\) , meaning that doubling the initial velocity results in a fourfold increase in range. Effect of Gravitational Acceleration \\(g\\) : \\[\\frac{dR}{dg} = -\\frac{v_0^2 \\sin 2\\theta}{g^2} < 0\\] The range \\(R\\) is inversely proportional to \\(g\\) , meaning that increasing gravity decreases the range. On celestial bodies with lower \\(g\\) (e.g., the Moon), the projectile travels much farther. Conclusion The range depends on both the angle and the initial velocity. The maximum range occurs at \\(45^\\circ\\) . Increasing the initial velocity significantly increases the range. A higher gravitational acceleration reduces the range. These principles are crucial in physics, engineering, and ballistics, influencing projectile motion analysis in various fields. Practical Applications of Differential Equations 1. Suspension Bridges Suspension bridges are modeled using second-order differential equations that describe the motion and forces acting on the structure. A common equation used in modeling is: \\[EI\\frac{d^4y}{dx^4}=q(x)\\] where: - \\(E\\) is the Young\u2019s modulus, - \\(I\\) is the second moment of area, - \\(y(x)\\) is the deflection of the bridge deck, - \\(q(x)\\) represents the distributed load. The natural frequency of oscillation is given by: \\[\\omega_n=\\sqrt{\\frac{k}{m}}\\] where \\(k\\) is the stiffness of the cables and \\(m\\) is the mass per unit length. 2. Energy Harvesting Systems Energy harvesting systems use vibrational energy to generate power, often modeled as a damped harmonic oscillator: \\[m\\frac{d^2x}{dt^2}+c\\frac{dx}{dt}+kx=F(t)\\] where: - \\(m\\) is the mass of the system, - \\(c\\) is the damping coefficient, - \\(k\\) is the stiffness, - \\(F(t)\\) represents the external driving force. A piezoelectric harvester converts mechanical energy into electrical energy, where the governing equation includes an electromechanical coupling term: \\[M\\ddot{X}+C\\dot{X}+KX=\\alpha V\\] \\[C_e\\dot{V}+GV=\\alpha\\dot{X}\\] where \\(V\\) is the voltage generated and \\(\\alpha\\) is the coupling coefficient. 3. Driven RLC Circuits An RLC circuit, consisting of a resistor \\(R\\) , inductor \\(L\\) , and capacitor \\(C\\) , is governed by: \\[L\\frac{d^2q}{dt^2}+R\\frac{dq}{dt}+\\frac{q}{C}=V(t)\\] where \\(q\\) is the charge and \\(V(t)\\) is an external driving voltage. For an AC-driven circuit: \\[V(t)=V_0\\cos(\\omega t)\\] The steady-state solution is given by: \\[I(t)=I_0\\cos(\\omega t-\\phi)\\] where the phase shift \\(\\phi\\) is determined by: \\[\\tan\\phi=\\frac{\\omega L-\\frac{1}{\\omega C}}{R}\\] These applications illustrate the fundamental role of differential equations in engineering and physics, governing complex systems from mechanical oscillations to electrical circuits. 4 phyton /plot import numpy as np import matplotlib.pyplot as plt # Constants g = 9.8 # Acceleration due to gravity (m/s^2) # Function to calculate the trajectory def calculate_trajectory(v0, theta_deg): theta_rad = np.radians(theta_deg) # Convert angle to radians t_max = 2 * v0 * np.sin(theta_rad) / g # Total time of flight t = np.linspace(0, t_max, 500) # Time array # Calculate x and y coordinates x = v0 * np.cos(theta_rad) * t y = v0 * np.sin(theta_rad) * t - 0.5 * g * t**2 # Filter out points where y < 0 valid_indices = y >= 0 x = x[valid_indices] y = y[valid_indices] return x, y # Part (a): Different Initial Velocities at 45\u00b0 plt.figure(figsize=(10, 6)) plt.subplot(2, 1, 1) initial_velocities = [30, 40, 50] colors = ['red', 'purple', 'green'] labels = ['30 m/s', '40 m/s', '50 m/s'] for v0, color, label in zip(initial_velocities, colors, labels): x, y = calculate_trajectory(v0, 45) plt.plot(x, y, label=label, color=color) plt.xlabel('Horizontal Distance (x) [m]') plt.ylabel('Vertical Height (y) [m]') plt.title('(a) Different Initial Velocities at 45\u00b0') plt.legend() plt.grid(True) # Part (b): Different Launch Angles at 50 m/s plt.subplot(2, 1, 2) launch_angles = [15, 45, 75, 50] colors = ['red', 'purple', 'green', 'blue'] labels = ['15\u00b0', '45\u00b0', '75\u00b0', '50\u00b0'] for theta, color, label in zip(launch_angles, colors, labels): x, y = calculate_trajectory(50, theta) plt.plot(x, y, label=label, color=color) plt.xlabel('Horizontal Distance (x) [m]') plt.ylabel('Vertical Height (y) [m]') plt.title('(b) Different Launch Angles at 50 m/s') plt.legend() plt.grid(True) plt.tight_layout() plt.show() Colab Colab","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#theoretical-foundation","text":"","title":"Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#derivation-of-governing-equations-of-motion","text":"Projectile motion is governed by Newton's Second Law: \\(F=ma\\) In the absence of air resistance, the only force acting on a projectile is gravity. Assuming motion in two dimensions (horizontal \\(x\\) and vertical \\(y\\) ), we express the acceleration components as: \\(a_x=0,\\quad a_y=-g\\) where \\(g\\) is the acceleration due to gravity. Using kinematic equations: \\(v=v_0+at\\) \\(s=s_0+v_0t+\\frac{1}{2}at^2\\) For horizontal motion: \\(v_x=v_0\\cos\\theta\\) \\(x=v_0\\cos\\theta\\cdot t\\) For vertical motion: \\(v_y=v_0\\sin\\theta-gt\\) \\(y=v_0\\sin\\theta\\cdot t-\\frac{1}{2}gt^2\\) where: - \\(v_0\\) is the initial velocity, - \\(\\theta\\) is the launch angle, - \\(t\\) is time.","title":"Derivation of Governing Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#solving-the-basic-differential-equations","text":"The motion of the projectile can also be described using differential equations: \\[\\frac{d^2x}{dt^2}=0,\\quad\\frac{d^2y}{dt^2}=-g\\] Integrating both equations: \\[\\frac{dx}{dt}=v_0\\cos\\theta\\] \\[\\frac{dy}{dt}=v_0\\sin\\theta-gt\\] A second integration gives the position equations: \\[x(t)=v_0\\cos\\theta\\cdot t\\] \\[y(t)=v_0\\sin\\theta\\cdot t-\\frac{1}{2}gt^2\\]","title":"Solving the Basic Differential Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#effect-of-initial-conditions-on-trajectory","text":"","title":"Effect of Initial Conditions on Trajectory"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"Setting \\(y=0\\) to find the total flight time: \\[v_0\\sin\\theta\\cdot t-\\frac{1}{2}gt^2=0\\] Solving for \\(t\\) : \\[t=\\frac{2v_0\\sin\\theta}{g}\\]","title":"Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#maximum-height","text":"At the peak of the motion, \\(v_y=0\\) : \\[0=v_0\\sin\\theta-gt_{max}\\] Solving for \\(t_{max}\\) : \\[t_{max}=\\frac{v_0\\sin\\theta}{g}\\] Substituting into the vertical position equation: \\[H=\\frac{(v_0\\sin\\theta)^2}{2g}\\]","title":"Maximum Height"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-of-the-projectile","text":"The range \\(R\\) is given by: \\[R=v_0\\cos\\theta\\cdot t_{total}\\] Substituting \\(t_{total}=\\frac{2v_0\\sin\\theta}{g}\\) : \\[R=\\frac{v_0^2\\sin2\\theta}{g}\\]","title":"Range of the Projectile"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#observations","text":"The range is maximized at \\(\\theta=45^\\circ\\) . Doubling the initial velocity quadruples the range. Increasing \\(g\\) decreases the range. These equations provide a foundation for further analysis, including air resistance and varying gravitational fields.","title":"Observations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#analysis-of-the-range","text":"","title":"Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#dependence-of-range-on-angle-of-projection","text":"The range \\(R\\) of a projectile launched with an initial velocity \\(v_0\\) at an angle \\(heta\\) from the horizontal is given by the equation: \\[R = \\frac{v_0^2 \\sin 2\\theta}{g}\\] where: - \\(v_0\\) is the initial velocity, - \\(heta\\) is the angle of projection, - \\(g\\) is the acceleration due to gravity.","title":"Dependence of Range on Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#analysis","text":"The range \\(R\\) is maximized when \\(\\sin 2 heta = 1\\) , which occurs at \\(2 heta = 90^\\circ\\) , or \\(heta = 45^\\circ\\) . For angles \\(heta > 45^\\circ\\) or \\(heta < 45^\\circ\\) , the range decreases. The function \\(\\sin 2 heta\\) is symmetric about \\(45^\\circ\\) , meaning that angles \\(heta\\) and \\(90^\\circ - heta\\) produce the same range.","title":"Analysis:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#effect-of-initial-velocity-and-gravitational-acceleration-on-range","text":"Since the range equation is: \\[R = \\frac{v_0^2 \\sin 2\\theta}{g},\\] we can analyze the influence of \\(v_0\\) and \\(g\\) :","title":"Effect of Initial Velocity and Gravitational Acceleration on Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#effect-of-initial-velocity-v_0","text":"\\[\\frac{dR}{dv_0} = \\frac{2 v_0 \\sin 2\\theta}{g} > 0\\] The range \\(R\\) increases quadratically with \\(v_0\\) , meaning that doubling the initial velocity results in a fourfold increase in range.","title":"Effect of Initial Velocity \\(v_0\\):"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#effect-of-gravitational-acceleration-g","text":"\\[\\frac{dR}{dg} = -\\frac{v_0^2 \\sin 2\\theta}{g^2} < 0\\] The range \\(R\\) is inversely proportional to \\(g\\) , meaning that increasing gravity decreases the range. On celestial bodies with lower \\(g\\) (e.g., the Moon), the projectile travels much farther.","title":"Effect of Gravitational Acceleration \\(g\\):"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"The range depends on both the angle and the initial velocity. The maximum range occurs at \\(45^\\circ\\) . Increasing the initial velocity significantly increases the range. A higher gravitational acceleration reduces the range. These principles are crucial in physics, engineering, and ballistics, influencing projectile motion analysis in various fields.","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#practical-applications-of-differential-equations","text":"","title":"Practical Applications of Differential Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-suspension-bridges","text":"Suspension bridges are modeled using second-order differential equations that describe the motion and forces acting on the structure. A common equation used in modeling is: \\[EI\\frac{d^4y}{dx^4}=q(x)\\] where: - \\(E\\) is the Young\u2019s modulus, - \\(I\\) is the second moment of area, - \\(y(x)\\) is the deflection of the bridge deck, - \\(q(x)\\) represents the distributed load. The natural frequency of oscillation is given by: \\[\\omega_n=\\sqrt{\\frac{k}{m}}\\] where \\(k\\) is the stiffness of the cables and \\(m\\) is the mass per unit length.","title":"1. Suspension Bridges"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-energy-harvesting-systems","text":"Energy harvesting systems use vibrational energy to generate power, often modeled as a damped harmonic oscillator: \\[m\\frac{d^2x}{dt^2}+c\\frac{dx}{dt}+kx=F(t)\\] where: - \\(m\\) is the mass of the system, - \\(c\\) is the damping coefficient, - \\(k\\) is the stiffness, - \\(F(t)\\) represents the external driving force. A piezoelectric harvester converts mechanical energy into electrical energy, where the governing equation includes an electromechanical coupling term: \\[M\\ddot{X}+C\\dot{X}+KX=\\alpha V\\] \\[C_e\\dot{V}+GV=\\alpha\\dot{X}\\] where \\(V\\) is the voltage generated and \\(\\alpha\\) is the coupling coefficient.","title":"2. Energy Harvesting Systems"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-driven-rlc-circuits","text":"An RLC circuit, consisting of a resistor \\(R\\) , inductor \\(L\\) , and capacitor \\(C\\) , is governed by: \\[L\\frac{d^2q}{dt^2}+R\\frac{dq}{dt}+\\frac{q}{C}=V(t)\\] where \\(q\\) is the charge and \\(V(t)\\) is an external driving voltage. For an AC-driven circuit: \\[V(t)=V_0\\cos(\\omega t)\\] The steady-state solution is given by: \\[I(t)=I_0\\cos(\\omega t-\\phi)\\] where the phase shift \\(\\phi\\) is determined by: \\[\\tan\\phi=\\frac{\\omega L-\\frac{1}{\\omega C}}{R}\\] These applications illustrate the fundamental role of differential equations in engineering and physics, governing complex systems from mechanical oscillations to electrical circuits.","title":"3. Driven RLC Circuits"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-phyton-plot","text":"import numpy as np import matplotlib.pyplot as plt # Constants g = 9.8 # Acceleration due to gravity (m/s^2) # Function to calculate the trajectory def calculate_trajectory(v0, theta_deg): theta_rad = np.radians(theta_deg) # Convert angle to radians t_max = 2 * v0 * np.sin(theta_rad) / g # Total time of flight t = np.linspace(0, t_max, 500) # Time array # Calculate x and y coordinates x = v0 * np.cos(theta_rad) * t y = v0 * np.sin(theta_rad) * t - 0.5 * g * t**2 # Filter out points where y < 0 valid_indices = y >= 0 x = x[valid_indices] y = y[valid_indices] return x, y # Part (a): Different Initial Velocities at 45\u00b0 plt.figure(figsize=(10, 6)) plt.subplot(2, 1, 1) initial_velocities = [30, 40, 50] colors = ['red', 'purple', 'green'] labels = ['30 m/s', '40 m/s', '50 m/s'] for v0, color, label in zip(initial_velocities, colors, labels): x, y = calculate_trajectory(v0, 45) plt.plot(x, y, label=label, color=color) plt.xlabel('Horizontal Distance (x) [m]') plt.ylabel('Vertical Height (y) [m]') plt.title('(a) Different Initial Velocities at 45\u00b0') plt.legend() plt.grid(True) # Part (b): Different Launch Angles at 50 m/s plt.subplot(2, 1, 2) launch_angles = [15, 45, 75, 50] colors = ['red', 'purple', 'green', 'blue'] labels = ['15\u00b0', '45\u00b0', '75\u00b0', '50\u00b0'] for theta, color, label in zip(launch_angles, colors, labels): x, y = calculate_trajectory(50, theta) plt.plot(x, y, label=label, color=color) plt.xlabel('Horizontal Distance (x) [m]') plt.ylabel('Vertical Height (y) [m]') plt.title('(b) Different Launch Angles at 50 m/s') plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"4 phyton /plot"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#colab","text":"Colab","title":"Colab"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 1. Theoretical Foundation 1.1 Governing Equation: Forced Damped Pendulum Consider a pendulum of length \\(L\\) and mass \\(m\\) subject to damping and an external periodic driving force. Let \\(\\theta(t)\\) be the angular displacement from the vertical. The torque \\(\\tau\\) acting on the pendulum includes: Restoring torque : \\(-mgL \\sin(\\theta)\\) Damping torque : \\(-b \\dot{\\theta}\\) , where \\(b\\) is the damping coefficient Driving torque : \\(F_0 \\cos(\\omega t)\\) , where \\(F_0\\) is the forcing amplitude and \\(\\omega\\) is the driving frequency Using Newton\u2019s second law for rotational motion: \\[ I \\ddot{\\theta} = -mgL \\sin(\\theta) - b \\dot{\\theta} + F_0 \\cos(\\omega t) \\] For a simple pendulum, the moment of inertia about the pivot is \\(I = mL^2\\) , hence: \\[ mL^2 \\ddot{\\theta} + b \\dot{\\theta} + mgL \\sin(\\theta) = F_0 \\cos(\\omega t) \\] Dividing through by \\(mL^2\\) : \\[ \\ddot{\\theta} + \\frac{b}{mL^2} \\dot{\\theta} + \\frac{g}{L} \\sin(\\theta) = \\frac{F_0}{mL^2} \\cos(\\omega t) \\] Define: \\(\\gamma = \\frac{b}{mL^2}\\) (damping ratio) \\(\\omega_0^2 = \\frac{g}{L}\\) (natural frequency squared) \\(f = \\frac{F_0}{mL^2}\\) (normalized driving amplitude) Then the equation becomes: \\[ \\ddot{\\theta} + \\gamma \\dot{\\theta} + \\omega_0^2 \\sin(\\theta) = f \\cos(\\omega t) \\] This is the nonlinear second-order differential equation governing a forced damped pendulum . 1.2 Small-Angle Approximation and Linearization For small angular displacements , we use the approximation: \\[ \\sin(\\theta) \\approx \\theta \\] Then the equation reduces to a linear differential equation : \\[ \\ddot{\\theta} + \\gamma \\dot{\\theta} + \\omega_0^2 \\theta = f \\cos(\\omega t) \\] This is a linear nonhomogeneous second-order ODE with constant coefficients. Homogeneous Solution: Solve: \\[ \\ddot{\\theta} + \\gamma \\dot{\\theta} + \\omega_0^2 \\theta = 0 \\] Assume solution of the form \\(\\theta(t) = e^{\\lambda t}\\) : \\[ \\lambda^2 + \\gamma \\lambda + \\omega_0^2 = 0 \\] The characteristic equation has roots: \\[ \\lambda = \\frac{-\\gamma \\pm \\sqrt{\\gamma^2 - 4 \\omega_0^2}}{2} \\] The behavior depends on the discriminant \\(\\Delta = \\gamma^2 - 4\\omega_0^2\\) : Underdamped \\((\\gamma^2 < 4\\omega_0^2)\\) : oscillatory decay Critically damped \\((\\gamma^2 = 4\\omega_0^2)\\) : fastest non-oscillatory decay Overdamped \\((\\gamma^2 > 4\\omega_0^2)\\) : slow non-oscillatory decay 1.3 Steady-State Solution and Resonance We seek a particular solution of the form: \\[ \\theta_p(t) = A \\cos(\\omega t - \\delta) \\] Substitute into the linearized equation: \\[ \\ddot{\\theta}_p + \\gamma \\dot{\\theta}_p + \\omega_0^2 \\theta_p = f \\cos(\\omega t) \\] Compute derivatives: \\(\\dot{\\theta}_p = -A \\omega \\sin(\\omega t - \\delta)\\) \\(\\ddot{\\theta}_p = -A \\omega^2 \\cos(\\omega t - \\delta)\\) Substitute and equate coefficients: \\[ -A \\omega^2 \\cos(\\omega t - \\delta) - \\gamma A \\omega \\sin(\\omega t - \\delta) + \\omega_0^2 A \\cos(\\omega t - \\delta) = f \\cos(\\omega t) \\] Using phasor (complex) representation or matching coefficients: \\[ A = \\frac{f}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + \\gamma^2 \\omega^2}} \\] \\[ \\tan(\\delta) = \\frac{\\gamma \\omega}{\\omega_0^2 - \\omega^2} \\] 1.4 Resonance Analysis Resonance occurs when the driving frequency \\(\\omega\\) approaches the system's natural frequency \\(\\omega_0\\) . In the absence of damping \\((\\gamma = 0)\\) , the amplitude becomes: \\[ A \\to \\infty \\quad \\text{as} \\quad \\omega \\to \\omega_0 \\] With damping, resonance occurs at: \\[ \\omega_r = \\sqrt{\\omega_0^2 - \\frac{\\gamma^2}{2}} \\] and the amplitude at resonance is: \\[ A_{\\text{max}} = \\frac{f}{\\gamma \\omega_r} \\] Energy Considerations: The system's mechanical energy \\(E\\) is a combination of kinetic and potential energy: \\[ E(t) = \\frac{1}{2} mL^2 \\dot{\\theta}^2 + mgL (1 - \\cos(\\theta)) \\] Due to damping, energy dissipates over time unless sustained by the driving force. At resonance, energy input from the driving force maximally compensates for the energy loss, leading to large steady-state oscillations. 2. Analysis of Dynamics 2.1 Effect of the Damping Coefficient \\(\\gamma\\) The damping coefficient \\(\\gamma = \\frac{b}{mL^2}\\) governs the rate of energy loss in the pendulum system. Starting from the linearized equation: \\[ \\ddot{\\theta} + \\gamma \\dot{\\theta} + \\omega_0^2 \\theta = f \\cos(\\omega t) \\] Cases: No damping \\((\\gamma = 0)\\) : Pure resonance at \\(\\omega = \\omega_0\\) Energy grows unbounded in the linear model Underdamping \\((0 < \\gamma < 2\\omega_0)\\) : Oscillatory motion with exponential decay Resonance still occurs, but with finite amplitude Critical damping \\((\\gamma = 2\\omega_0)\\) : Fastest return to equilibrium without oscillations Overdamping \\((\\gamma > 2\\omega_0)\\) : Slow, monotonic return to equilibrium Damping controls the sharpness of the resonance peak and the rate of energy dissipation . 2.2 Effect of Driving Amplitude \\(f\\) Increasing the driving amplitude \\(f\\) affects the steady-state amplitude of oscillations: \\[ A = \\frac{f}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + \\gamma^2 \\omega^2}} \\] For fixed \\(\\omega\\) and \\(\\gamma\\) , the amplitude grows linearly with \\(f\\) Larger \\(f\\) can lead to nonlinear behavior , particularly when \\(\\theta\\) is no longer small Physical Implication: A stronger external forcing can excite higher-order modes , break linear assumptions, and push the pendulum into complex or chaotic regimes . 2.3 Effect of Driving Frequency \\(\\omega\\) Driving frequency \\(\\omega\\) plays a crucial role in determining system behavior: At low frequencies \\((\\omega \\ll \\omega_0)\\) : system follows the driving force closely At resonance \\((\\omega \\approx \\omega_r)\\) : maximum energy transfer and oscillation amplitude At high frequencies \\((\\omega \\gg \\omega_0)\\) : system cannot respond effectively; small oscillations Amplitude as a function of \\(\\omega\\) : \\[ A(\\omega) = \\frac{f}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + \\gamma^2 \\omega^2}} \\] Resonance peak shifts lower as \\(\\gamma\\) increases. 2.4 Conditions for Regular Motion Regular (periodic) motion occurs under the following conditions: Low driving amplitude \\(f\\) Moderate damping \\(\\gamma\\) Driving frequency \\(\\omega\\) not near chaotic windows Under these conditions, the system settles into: Steady-state periodic oscillations with the same frequency as the drive Phase-locked behavior where \\(\\theta(t)\\) repeats with period \\(T = \\frac{2\\pi}{\\omega}\\) Physical Significance: Regular motion implies predictability and energy balance \u2014the driving force supplies just enough energy to offset damping losses without overwhelming the system. 2.5 Transition to Chaos For larger \\(f\\) and small \\(\\gamma\\) , the system becomes nonlinear and potentially chaotic : Original nonlinear equation: \\[ \\ddot{\\theta} + \\gamma \\dot{\\theta} + \\omega_0^2 \\sin(\\theta) = f \\cos(\\omega t) \\] Characteristics of chaotic motion: Aperiodicity : No repeating patterns in \\(\\theta(t)\\) Sensitivity to initial conditions : Tiny differences in \\(\\theta_0\\) lead to vastly different trajectories Strange attractors in phase space Bifurcation and Route to Chaos: As \\(f\\) increases: - Period doubling bifurcations occur: \\(T \\to 2T \\to 4T \\to \\dots\\) - Eventually leads to chaos Chaos diagram (not shown here) reveals windows of order amidst disorder (e.g., Feigenbaum route ). Physical Implications: Chaos implies the system: - Is deterministic but unpredictable - Shows complexity from simple rules - Models real-world phenomena like climate systems, electrical circuits, and biological rhythms 3. Practical Applications The forced damped pendulum serves as a foundational model in various fields of science and engineering, providing insight into the behavior of nonlinear oscillatory systems. 3.1 Real-World Systems Modeled by the Forced Damped Pendulum 1. Energy Harvesting Devices Piezoelectric Energy Scavengers : Convert ambient vibrational energy into electrical energy. Modeled as pendulum-like oscillators subject to environmental forcing. Optimal power output occurs near resonance conditions. 2. Suspension Bridges and Skyscrapers Bridges like the Tacoma Narrows exhibit aeroelastic oscillations . Subject to damping (wind resistance, structural friction) and forcing (wind gusts, traffic). Analysis helps in designing tuned mass dampers to prevent catastrophic resonance. 3. Oscillating Electrical Circuits RLC Circuits exhibit behavior analogous to a forced damped pendulum: $$ L \\ddot{q} + R \\dot{q} + \\frac{1}{C} q = V_0 \\cos(\\omega t) $$ \\(L\\) : inductance (analogous to mass) \\(R\\) : resistance (analogous to damping) \\(1/C\\) : restoring force (analogous to gravity) \\(V_0 \\cos(\\omega t)\\) : external driving voltage Insights from pendulum dynamics guide filter design, resonance tuning, and damping controls. 4. Clock Mechanisms and Seismology Pendulum clocks use controlled oscillations for timekeeping. Seismometers model ground motion as a forced oscillator; resonance tuning enhances sensitivity to specific frequencies. 5. Biomechanics and Robotics Legged locomotion : Walking and running involve pendulum-like leg swings. Damping models joint resistance; external driving models muscular input or terrain forces. Used to optimize energy-efficient gait patterns. 3.2 Relevance of Pendulum Dynamics to Applications The rich dynamic behavior of the forced damped pendulum informs: Design for stability : Avoidance of resonance in mechanical structures Implementation of damping to suppress undesired oscillations Energy optimization : Maximize output in energy harvesting by tuning \\(\\omega\\) and \\(\\gamma\\) Match environmental frequencies to mechanical resonances Control systems : Pendulum models underpin feedback control in robotic limbs and aerospace navigation Phase synchronization and resonance locking applied in phase-locked loops (PLLs) Prediction and prevention of chaos : Recognizing chaotic regimes helps engineers avoid failure modes in bridges, engines, or circuits Phase diagrams and bifurcation analysis provide early warning tools 3. Practical Applications The forced damped pendulum serves as a foundational model in various fields of science and engineering, providing insight into the behavior of nonlinear oscillatory systems. 3.1 Real-World Systems Modeled by the Forced Damped Pendulum 1. Energy Harvesting Devices Piezoelectric Energy Scavengers : Convert ambient vibrational energy into electrical energy. Modeled as pendulum-like oscillators subject to environmental forcing. Optimal power output occurs near resonance conditions. 2. Suspension Bridges and Skyscrapers Bridges like the Tacoma Narrows exhibit aeroelastic oscillations . Subject to damping (wind resistance, structural friction) and forcing (wind gusts, traffic). Analysis helps in designing tuned mass dampers to prevent catastrophic resonance. 3. Oscillating Electrical Circuits RLC Circuits exhibit behavior analogous to a forced damped pendulum: $$ L \\ddot{q} + R \\dot{q} + \\frac{1}{C} q = V_0 \\cos(\\omega t) $$ \\(L\\) : inductance (analogous to mass) \\(R\\) : resistance (analogous to damping) \\(1/C\\) : restoring force (analogous to gravity) \\(V_0 \\cos(\\omega t)\\) : external driving voltage Insights from pendulum dynamics guide filter design, resonance tuning, and damping controls. 4. Clock Mechanisms and Seismology Pendulum clocks use controlled oscillations for timekeeping. Seismometers model ground motion as a forced oscillator; resonance tuning enhances sensitivity to specific frequencies. 5. Biomechanics and Robotics Legged locomotion : Walking and running involve pendulum-like leg swings. Damping models joint resistance; external driving models muscular input or terrain forces. Used to optimize energy-efficient gait patterns. 3.2 Relevance of Pendulum Dynamics to Applications The rich dynamic behavior of the forced damped pendulum informs: Design for stability : Avoidance of resonance in mechanical structures Implementation of damping to suppress undesired oscillations Energy optimization : Maximize output in energy harvesting by tuning \\(\\omega\\) and \\(\\gamma\\) Match environmental frequencies to mechanical resonances Control systems : Pendulum models underpin feedback control in robotic limbs and aerospace navigation Phase synchronization and resonance locking applied in phase-locked loops (PLLs) Prediction and prevention of chaos : Recognizing chaotic regimes helps engineers avoid failure modes in bridges, engines, or circuits Phase diagrams and bifurcation analysis provide early warning tools Code and Plots Pendulum Visualizations import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the parameters g = 9.81 # acceleration due to gravity (m/s^2) L = 1.0 # length of the pendulum (m) omega_0 = np.sqrt(g / L) # natural frequency of the pendulum # Time span for simulation t_span = (0, 40) # from 0 to 40 seconds t_eval = np.linspace(t_span[0], t_span[1], 1000) # time points for evaluation # Initial conditions: [theta, angular velocity] theta0 = 0.2 # initial angle (radians) omega0 = 0.0 # initial angular velocity (rad/s) y0 = [theta0, omega0] # 1) Simple Pendulum def simple_pendulum(t, y): theta, omega = y dtheta_dt = omega domega_dt = -(g / L) * np.sin(theta) return [dtheta_dt, domega_dt] sol_simple = solve_ivp(simple_pendulum, t_span, y0, t_eval=t_eval) # 2) Damped Pendulum def damped_pendulum(t, y): theta, omega = y damping_coefficient = 0.5 dtheta_dt = omega domega_dt = -(g / L) * np.sin(theta) - damping_coefficient * omega return [dtheta_dt, domega_dt] sol_damped = solve_ivp(damped_pendulum, t_span, y0, t_eval=t_eval) # 3) Forced Pendulum def forced_pendulum(t, y): theta, omega = y forcing_amplitude = 1.5 forcing_frequency = 0.67 * omega_0 damping_coefficient = 0.2 dtheta_dt = omega domega_dt = -(g / L) * np.sin(theta) - damping_coefficient * omega + forcing_amplitude * np.cos(forcing_frequency * t) return [dtheta_dt, domega_dt] sol_forced = solve_ivp(forced_pendulum, t_span, y0, t_eval=t_eval) # 4) Chaotic Pendulum (double forcing) def chaotic_forced_pendulum(t, y): theta, omega = y A1 = 1.2 A2 = 1.0 f1 = 0.67 * omega_0 f2 = np.pi * omega_0 # incommensurate frequency damping_coefficient = 0.3 dtheta_dt = omega domega_dt = -(g / L) * np.sin(theta) - damping_coefficient * omega + A1 * np.cos(f1 * t) + A2 * np.cos(f2 * t) return [dtheta_dt, domega_dt] sol_chaotic = solve_ivp(chaotic_forced_pendulum, t_span, y0, t_eval=t_eval) # 5) Near-resonance pendulum def near_resonance_pendulum(t, y): theta, omega = y forcing_amplitude = 1.0 forcing_frequency = omega_0 # close to resonance damping_coefficient = 0.05 # very light damping dtheta_dt = omega domega_dt = -(g / L) * np.sin(theta) - damping_coefficient * omega + forcing_amplitude * np.cos(forcing_frequency * t) return [dtheta_dt, domega_dt] sol_resonance = solve_ivp(near_resonance_pendulum, t_span, y0, t_eval=t_eval) # ---------------------- Plotting ---------------------- fig, axes = plt.subplots(5, 2, figsize=(14, 24)) # Utility to plot each scenario def plot_pendulum(ax_time, ax_phase, sol, title_prefix, color): ax_time.plot(sol.t, sol.y[0], color=color) ax_time.set_title(f'{title_prefix} - Time Series') ax_time.set_xlabel('Time (s)') ax_time.set_ylabel('\u03b8 (rad)') ax_time.grid(True) ax_phase.plot(sol.y[0], sol.y[1], color=color) ax_phase.set_title(f'{title_prefix} - Phase Portrait') ax_phase.set_xlabel('\u03b8 (rad)') ax_phase.set_ylabel('\u03c9 (rad/s)') ax_phase.grid(True) # Plot each system plot_pendulum(axes[0, 0], axes[0, 1], sol_simple, \"1) Simple Pendulum\", 'red') plot_pendulum(axes[1, 0], axes[1, 1], sol_damped, \"2) Damped Pendulum\", 'purple') plot_pendulum(axes[2, 0], axes[2, 1], sol_forced, \"3) Forced Pendulum\", 'cyan') plot_pendulum(axes[3, 0], axes[3, 1], sol_chaotic, \"4) Chaotic Forced Pendulum\", 'green') plot_pendulum(axes[4, 0], axes[4, 1], sol_resonance, \"5) Near-Resonance Pendulum\", 'orange') plt.tight_layout() plt.show() Colab Colab","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#11-governing-equation-forced-damped-pendulum","text":"Consider a pendulum of length \\(L\\) and mass \\(m\\) subject to damping and an external periodic driving force. Let \\(\\theta(t)\\) be the angular displacement from the vertical. The torque \\(\\tau\\) acting on the pendulum includes: Restoring torque : \\(-mgL \\sin(\\theta)\\) Damping torque : \\(-b \\dot{\\theta}\\) , where \\(b\\) is the damping coefficient Driving torque : \\(F_0 \\cos(\\omega t)\\) , where \\(F_0\\) is the forcing amplitude and \\(\\omega\\) is the driving frequency Using Newton\u2019s second law for rotational motion: \\[ I \\ddot{\\theta} = -mgL \\sin(\\theta) - b \\dot{\\theta} + F_0 \\cos(\\omega t) \\] For a simple pendulum, the moment of inertia about the pivot is \\(I = mL^2\\) , hence: \\[ mL^2 \\ddot{\\theta} + b \\dot{\\theta} + mgL \\sin(\\theta) = F_0 \\cos(\\omega t) \\] Dividing through by \\(mL^2\\) : \\[ \\ddot{\\theta} + \\frac{b}{mL^2} \\dot{\\theta} + \\frac{g}{L} \\sin(\\theta) = \\frac{F_0}{mL^2} \\cos(\\omega t) \\] Define: \\(\\gamma = \\frac{b}{mL^2}\\) (damping ratio) \\(\\omega_0^2 = \\frac{g}{L}\\) (natural frequency squared) \\(f = \\frac{F_0}{mL^2}\\) (normalized driving amplitude) Then the equation becomes: \\[ \\ddot{\\theta} + \\gamma \\dot{\\theta} + \\omega_0^2 \\sin(\\theta) = f \\cos(\\omega t) \\] This is the nonlinear second-order differential equation governing a forced damped pendulum .","title":"1.1 Governing Equation: Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#12-small-angle-approximation-and-linearization","text":"For small angular displacements , we use the approximation: \\[ \\sin(\\theta) \\approx \\theta \\] Then the equation reduces to a linear differential equation : \\[ \\ddot{\\theta} + \\gamma \\dot{\\theta} + \\omega_0^2 \\theta = f \\cos(\\omega t) \\] This is a linear nonhomogeneous second-order ODE with constant coefficients.","title":"1.2 Small-Angle Approximation and Linearization"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#homogeneous-solution","text":"Solve: \\[ \\ddot{\\theta} + \\gamma \\dot{\\theta} + \\omega_0^2 \\theta = 0 \\] Assume solution of the form \\(\\theta(t) = e^{\\lambda t}\\) : \\[ \\lambda^2 + \\gamma \\lambda + \\omega_0^2 = 0 \\] The characteristic equation has roots: \\[ \\lambda = \\frac{-\\gamma \\pm \\sqrt{\\gamma^2 - 4 \\omega_0^2}}{2} \\] The behavior depends on the discriminant \\(\\Delta = \\gamma^2 - 4\\omega_0^2\\) : Underdamped \\((\\gamma^2 < 4\\omega_0^2)\\) : oscillatory decay Critically damped \\((\\gamma^2 = 4\\omega_0^2)\\) : fastest non-oscillatory decay Overdamped \\((\\gamma^2 > 4\\omega_0^2)\\) : slow non-oscillatory decay","title":"Homogeneous Solution:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#13-steady-state-solution-and-resonance","text":"We seek a particular solution of the form: \\[ \\theta_p(t) = A \\cos(\\omega t - \\delta) \\] Substitute into the linearized equation: \\[ \\ddot{\\theta}_p + \\gamma \\dot{\\theta}_p + \\omega_0^2 \\theta_p = f \\cos(\\omega t) \\] Compute derivatives: \\(\\dot{\\theta}_p = -A \\omega \\sin(\\omega t - \\delta)\\) \\(\\ddot{\\theta}_p = -A \\omega^2 \\cos(\\omega t - \\delta)\\) Substitute and equate coefficients: \\[ -A \\omega^2 \\cos(\\omega t - \\delta) - \\gamma A \\omega \\sin(\\omega t - \\delta) + \\omega_0^2 A \\cos(\\omega t - \\delta) = f \\cos(\\omega t) \\] Using phasor (complex) representation or matching coefficients: \\[ A = \\frac{f}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + \\gamma^2 \\omega^2}} \\] \\[ \\tan(\\delta) = \\frac{\\gamma \\omega}{\\omega_0^2 - \\omega^2} \\]","title":"1.3 Steady-State Solution and Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#14-resonance-analysis","text":"Resonance occurs when the driving frequency \\(\\omega\\) approaches the system's natural frequency \\(\\omega_0\\) . In the absence of damping \\((\\gamma = 0)\\) , the amplitude becomes: \\[ A \\to \\infty \\quad \\text{as} \\quad \\omega \\to \\omega_0 \\] With damping, resonance occurs at: \\[ \\omega_r = \\sqrt{\\omega_0^2 - \\frac{\\gamma^2}{2}} \\] and the amplitude at resonance is: \\[ A_{\\text{max}} = \\frac{f}{\\gamma \\omega_r} \\]","title":"1.4 Resonance Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#energy-considerations","text":"The system's mechanical energy \\(E\\) is a combination of kinetic and potential energy: \\[ E(t) = \\frac{1}{2} mL^2 \\dot{\\theta}^2 + mgL (1 - \\cos(\\theta)) \\] Due to damping, energy dissipates over time unless sustained by the driving force. At resonance, energy input from the driving force maximally compensates for the energy loss, leading to large steady-state oscillations.","title":"Energy Considerations:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#21-effect-of-the-damping-coefficient-gamma","text":"The damping coefficient \\(\\gamma = \\frac{b}{mL^2}\\) governs the rate of energy loss in the pendulum system. Starting from the linearized equation: \\[ \\ddot{\\theta} + \\gamma \\dot{\\theta} + \\omega_0^2 \\theta = f \\cos(\\omega t) \\]","title":"2.1 Effect of the Damping Coefficient \\(\\gamma\\)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#cases","text":"No damping \\((\\gamma = 0)\\) : Pure resonance at \\(\\omega = \\omega_0\\) Energy grows unbounded in the linear model Underdamping \\((0 < \\gamma < 2\\omega_0)\\) : Oscillatory motion with exponential decay Resonance still occurs, but with finite amplitude Critical damping \\((\\gamma = 2\\omega_0)\\) : Fastest return to equilibrium without oscillations Overdamping \\((\\gamma > 2\\omega_0)\\) : Slow, monotonic return to equilibrium Damping controls the sharpness of the resonance peak and the rate of energy dissipation .","title":"Cases:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#22-effect-of-driving-amplitude-f","text":"Increasing the driving amplitude \\(f\\) affects the steady-state amplitude of oscillations: \\[ A = \\frac{f}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + \\gamma^2 \\omega^2}} \\] For fixed \\(\\omega\\) and \\(\\gamma\\) , the amplitude grows linearly with \\(f\\) Larger \\(f\\) can lead to nonlinear behavior , particularly when \\(\\theta\\) is no longer small","title":"2.2 Effect of Driving Amplitude \\(f\\)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#physical-implication","text":"A stronger external forcing can excite higher-order modes , break linear assumptions, and push the pendulum into complex or chaotic regimes .","title":"Physical Implication:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#23-effect-of-driving-frequency-omega","text":"Driving frequency \\(\\omega\\) plays a crucial role in determining system behavior: At low frequencies \\((\\omega \\ll \\omega_0)\\) : system follows the driving force closely At resonance \\((\\omega \\approx \\omega_r)\\) : maximum energy transfer and oscillation amplitude At high frequencies \\((\\omega \\gg \\omega_0)\\) : system cannot respond effectively; small oscillations","title":"2.3 Effect of Driving Frequency \\(\\omega\\)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#amplitude-as-a-function-of-omega","text":"\\[ A(\\omega) = \\frac{f}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + \\gamma^2 \\omega^2}} \\] Resonance peak shifts lower as \\(\\gamma\\) increases.","title":"Amplitude as a function of \\(\\omega\\):"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#24-conditions-for-regular-motion","text":"Regular (periodic) motion occurs under the following conditions: Low driving amplitude \\(f\\) Moderate damping \\(\\gamma\\) Driving frequency \\(\\omega\\) not near chaotic windows Under these conditions, the system settles into: Steady-state periodic oscillations with the same frequency as the drive Phase-locked behavior where \\(\\theta(t)\\) repeats with period \\(T = \\frac{2\\pi}{\\omega}\\)","title":"2.4 Conditions for Regular Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#physical-significance","text":"Regular motion implies predictability and energy balance \u2014the driving force supplies just enough energy to offset damping losses without overwhelming the system.","title":"Physical Significance:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#25-transition-to-chaos","text":"For larger \\(f\\) and small \\(\\gamma\\) , the system becomes nonlinear and potentially chaotic : Original nonlinear equation: \\[ \\ddot{\\theta} + \\gamma \\dot{\\theta} + \\omega_0^2 \\sin(\\theta) = f \\cos(\\omega t) \\]","title":"2.5 Transition to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#characteristics-of-chaotic-motion","text":"Aperiodicity : No repeating patterns in \\(\\theta(t)\\) Sensitivity to initial conditions : Tiny differences in \\(\\theta_0\\) lead to vastly different trajectories Strange attractors in phase space","title":"Characteristics of chaotic motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#bifurcation-and-route-to-chaos","text":"As \\(f\\) increases: - Period doubling bifurcations occur: \\(T \\to 2T \\to 4T \\to \\dots\\) - Eventually leads to chaos Chaos diagram (not shown here) reveals windows of order amidst disorder (e.g., Feigenbaum route ).","title":"Bifurcation and Route to Chaos:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#physical-implications","text":"Chaos implies the system: - Is deterministic but unpredictable - Shows complexity from simple rules - Models real-world phenomena like climate systems, electrical circuits, and biological rhythms","title":"Physical Implications:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The forced damped pendulum serves as a foundational model in various fields of science and engineering, providing insight into the behavior of nonlinear oscillatory systems.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#31-real-world-systems-modeled-by-the-forced-damped-pendulum","text":"","title":"3.1 Real-World Systems Modeled by the Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-energy-harvesting-devices","text":"Piezoelectric Energy Scavengers : Convert ambient vibrational energy into electrical energy. Modeled as pendulum-like oscillators subject to environmental forcing. Optimal power output occurs near resonance conditions.","title":"1. Energy Harvesting Devices"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-suspension-bridges-and-skyscrapers","text":"Bridges like the Tacoma Narrows exhibit aeroelastic oscillations . Subject to damping (wind resistance, structural friction) and forcing (wind gusts, traffic). Analysis helps in designing tuned mass dampers to prevent catastrophic resonance.","title":"2. Suspension Bridges and Skyscrapers"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-oscillating-electrical-circuits","text":"RLC Circuits exhibit behavior analogous to a forced damped pendulum: $$ L \\ddot{q} + R \\dot{q} + \\frac{1}{C} q = V_0 \\cos(\\omega t) $$ \\(L\\) : inductance (analogous to mass) \\(R\\) : resistance (analogous to damping) \\(1/C\\) : restoring force (analogous to gravity) \\(V_0 \\cos(\\omega t)\\) : external driving voltage Insights from pendulum dynamics guide filter design, resonance tuning, and damping controls.","title":"3. Oscillating Electrical Circuits"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-clock-mechanisms-and-seismology","text":"Pendulum clocks use controlled oscillations for timekeeping. Seismometers model ground motion as a forced oscillator; resonance tuning enhances sensitivity to specific frequencies.","title":"4. Clock Mechanisms and Seismology"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-biomechanics-and-robotics","text":"Legged locomotion : Walking and running involve pendulum-like leg swings. Damping models joint resistance; external driving models muscular input or terrain forces. Used to optimize energy-efficient gait patterns.","title":"5. Biomechanics and Robotics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#32-relevance-of-pendulum-dynamics-to-applications","text":"The rich dynamic behavior of the forced damped pendulum informs: Design for stability : Avoidance of resonance in mechanical structures Implementation of damping to suppress undesired oscillations Energy optimization : Maximize output in energy harvesting by tuning \\(\\omega\\) and \\(\\gamma\\) Match environmental frequencies to mechanical resonances Control systems : Pendulum models underpin feedback control in robotic limbs and aerospace navigation Phase synchronization and resonance locking applied in phase-locked loops (PLLs) Prediction and prevention of chaos : Recognizing chaotic regimes helps engineers avoid failure modes in bridges, engines, or circuits Phase diagrams and bifurcation analysis provide early warning tools","title":"3.2 Relevance of Pendulum Dynamics to Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications_1","text":"The forced damped pendulum serves as a foundational model in various fields of science and engineering, providing insight into the behavior of nonlinear oscillatory systems.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#31-real-world-systems-modeled-by-the-forced-damped-pendulum_1","text":"","title":"3.1 Real-World Systems Modeled by the Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-energy-harvesting-devices_1","text":"Piezoelectric Energy Scavengers : Convert ambient vibrational energy into electrical energy. Modeled as pendulum-like oscillators subject to environmental forcing. Optimal power output occurs near resonance conditions.","title":"1. Energy Harvesting Devices"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-suspension-bridges-and-skyscrapers_1","text":"Bridges like the Tacoma Narrows exhibit aeroelastic oscillations . Subject to damping (wind resistance, structural friction) and forcing (wind gusts, traffic). Analysis helps in designing tuned mass dampers to prevent catastrophic resonance.","title":"2. Suspension Bridges and Skyscrapers"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-oscillating-electrical-circuits_1","text":"RLC Circuits exhibit behavior analogous to a forced damped pendulum: $$ L \\ddot{q} + R \\dot{q} + \\frac{1}{C} q = V_0 \\cos(\\omega t) $$ \\(L\\) : inductance (analogous to mass) \\(R\\) : resistance (analogous to damping) \\(1/C\\) : restoring force (analogous to gravity) \\(V_0 \\cos(\\omega t)\\) : external driving voltage Insights from pendulum dynamics guide filter design, resonance tuning, and damping controls.","title":"3. Oscillating Electrical Circuits"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-clock-mechanisms-and-seismology_1","text":"Pendulum clocks use controlled oscillations for timekeeping. Seismometers model ground motion as a forced oscillator; resonance tuning enhances sensitivity to specific frequencies.","title":"4. Clock Mechanisms and Seismology"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-biomechanics-and-robotics_1","text":"Legged locomotion : Walking and running involve pendulum-like leg swings. Damping models joint resistance; external driving models muscular input or terrain forces. Used to optimize energy-efficient gait patterns.","title":"5. Biomechanics and Robotics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#32-relevance-of-pendulum-dynamics-to-applications_1","text":"The rich dynamic behavior of the forced damped pendulum informs: Design for stability : Avoidance of resonance in mechanical structures Implementation of damping to suppress undesired oscillations Energy optimization : Maximize output in energy harvesting by tuning \\(\\omega\\) and \\(\\gamma\\) Match environmental frequencies to mechanical resonances Control systems : Pendulum models underpin feedback control in robotic limbs and aerospace navigation Phase synchronization and resonance locking applied in phase-locked loops (PLLs) Prediction and prevention of chaos : Recognizing chaotic regimes helps engineers avoid failure modes in bridges, engines, or circuits Phase diagrams and bifurcation analysis provide early warning tools","title":"3.2 Relevance of Pendulum Dynamics to Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#code-and-plots","text":"","title":"Code and Plots"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#pendulum-visualizations","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the parameters g = 9.81 # acceleration due to gravity (m/s^2) L = 1.0 # length of the pendulum (m) omega_0 = np.sqrt(g / L) # natural frequency of the pendulum # Time span for simulation t_span = (0, 40) # from 0 to 40 seconds t_eval = np.linspace(t_span[0], t_span[1], 1000) # time points for evaluation # Initial conditions: [theta, angular velocity] theta0 = 0.2 # initial angle (radians) omega0 = 0.0 # initial angular velocity (rad/s) y0 = [theta0, omega0] # 1) Simple Pendulum def simple_pendulum(t, y): theta, omega = y dtheta_dt = omega domega_dt = -(g / L) * np.sin(theta) return [dtheta_dt, domega_dt] sol_simple = solve_ivp(simple_pendulum, t_span, y0, t_eval=t_eval) # 2) Damped Pendulum def damped_pendulum(t, y): theta, omega = y damping_coefficient = 0.5 dtheta_dt = omega domega_dt = -(g / L) * np.sin(theta) - damping_coefficient * omega return [dtheta_dt, domega_dt] sol_damped = solve_ivp(damped_pendulum, t_span, y0, t_eval=t_eval) # 3) Forced Pendulum def forced_pendulum(t, y): theta, omega = y forcing_amplitude = 1.5 forcing_frequency = 0.67 * omega_0 damping_coefficient = 0.2 dtheta_dt = omega domega_dt = -(g / L) * np.sin(theta) - damping_coefficient * omega + forcing_amplitude * np.cos(forcing_frequency * t) return [dtheta_dt, domega_dt] sol_forced = solve_ivp(forced_pendulum, t_span, y0, t_eval=t_eval) # 4) Chaotic Pendulum (double forcing) def chaotic_forced_pendulum(t, y): theta, omega = y A1 = 1.2 A2 = 1.0 f1 = 0.67 * omega_0 f2 = np.pi * omega_0 # incommensurate frequency damping_coefficient = 0.3 dtheta_dt = omega domega_dt = -(g / L) * np.sin(theta) - damping_coefficient * omega + A1 * np.cos(f1 * t) + A2 * np.cos(f2 * t) return [dtheta_dt, domega_dt] sol_chaotic = solve_ivp(chaotic_forced_pendulum, t_span, y0, t_eval=t_eval) # 5) Near-resonance pendulum def near_resonance_pendulum(t, y): theta, omega = y forcing_amplitude = 1.0 forcing_frequency = omega_0 # close to resonance damping_coefficient = 0.05 # very light damping dtheta_dt = omega domega_dt = -(g / L) * np.sin(theta) - damping_coefficient * omega + forcing_amplitude * np.cos(forcing_frequency * t) return [dtheta_dt, domega_dt] sol_resonance = solve_ivp(near_resonance_pendulum, t_span, y0, t_eval=t_eval) # ---------------------- Plotting ---------------------- fig, axes = plt.subplots(5, 2, figsize=(14, 24)) # Utility to plot each scenario def plot_pendulum(ax_time, ax_phase, sol, title_prefix, color): ax_time.plot(sol.t, sol.y[0], color=color) ax_time.set_title(f'{title_prefix} - Time Series') ax_time.set_xlabel('Time (s)') ax_time.set_ylabel('\u03b8 (rad)') ax_time.grid(True) ax_phase.plot(sol.y[0], sol.y[1], color=color) ax_phase.set_title(f'{title_prefix} - Phase Portrait') ax_phase.set_xlabel('\u03b8 (rad)') ax_phase.set_ylabel('\u03c9 (rad/s)') ax_phase.grid(True) # Plot each system plot_pendulum(axes[0, 0], axes[0, 1], sol_simple, \"1) Simple Pendulum\", 'red') plot_pendulum(axes[1, 0], axes[1, 1], sol_damped, \"2) Damped Pendulum\", 'purple') plot_pendulum(axes[2, 0], axes[2, 1], sol_forced, \"3) Forced Pendulum\", 'cyan') plot_pendulum(axes[3, 0], axes[3, 1], sol_chaotic, \"4) Chaotic Forced Pendulum\", 'green') plot_pendulum(axes[4, 0], axes[4, 1], sol_resonance, \"5) Near-Resonance Pendulum\", 'orange') plt.tight_layout() plt.show()","title":"Pendulum Visualizations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#colab","text":"Colab","title":"Colab"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 1. Theoretical Derivation 1.1 Introduction To derive Kepler\u2019s Third Law for circular orbits, we begin with Newton's Law of Universal Gravitation and centripetal force . We aim to find a mathematical relationship between the orbital period squared and the orbital radius cubed , i.e., \\[ T^2 \\propto r^3 \\] This derivation assumes the orbiting body has negligible mass compared to the central mass and follows a perfectly circular orbit . 1.2 Newton's Law of Universal Gravitation Newton\u2019s law states that the gravitational force \\(F_g\\) between two point masses \\(m_1\\) and \\(m_2\\) separated by a distance \\(r\\) is given by: \\[ F_g = G \\frac{m_1 m_2}{r^2} \\] Where: - \\(F_g\\) is the gravitational force - \\(G\\) is the universal gravitational constant ( \\(6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2\\) ) - \\(r\\) is the separation between the centers of mass 1.3 Centripetal Force in Circular Motion For an object of mass \\(m\\) moving with orbital speed \\(v\\) in a circle of radius \\(r\\) , the required centripetal force \\(F_c\\) is: \\[ F_c = \\frac{m v^2}{r} \\] In a stable circular orbit, this force is provided entirely by gravity. Therefore: \\[ F_g = F_c \\] Substituting: \\[ G \\frac{M m}{r^2} = \\frac{m v^2}{r} \\] Cancel \\(m\\) (mass of the orbiting body) from both sides: \\[ G \\frac{M}{r^2} = \\frac{v^2}{r} \\] Multiply both sides by \\(r\\) : \\[ G \\frac{M}{r} = v^2 \\] 1.4 Orbital Period and Velocity The orbital period \\(T\\) is the time it takes for one full orbit. For a circular orbit, the distance traveled in one period is the circumference \\(2\\pi r\\) : \\[ v = \\frac{2\\pi r}{T} \\] Substitute this into the previous equation: \\[ G \\frac{M}{r} = \\left( \\frac{2\\pi r}{T} \\right)^2 \\] Expand the right-hand side: \\[ G \\frac{M}{r} = \\frac{4\\pi^2 r^2}{T^2} \\] Multiply both sides by \\(T^2\\) : \\[ G M T^2 = 4\\pi^2 r^3 \\] Finally, solve for \\(T^2\\) : \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] 1.5 Final Form of Kepler\u2019s Third Law This is the mathematical expression of Kepler\u2019s Third Law for circular orbits: \\[ T^2 \\propto r^3 \\] The constant of proportionality is \\(\\frac{4\\pi^2}{G M}\\) , which depends on the mass \\(M\\) of the central object. 2. Astronomical Implications 2.1 Determining Planetary Masses Using Kepler's Third Law Kepler\u2019s Third Law, when combined with Newtonian mechanics, allows us to calculate the mass of a central celestial body \u2014such as a planet or star\u2014by observing the motion of an orbiting object. From the derived formula: \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] Rearranging to solve for \\(M\\) : \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] Where: - \\(r\\) is the orbital radius - \\(T\\) is the orbital period - \\(M\\) is the mass of the central body - \\(G\\) is the gravitational constant Example : By observing a moon orbiting a planet and measuring its orbital radius and period, we can calculate the planet\u2019s mass precisely. 2.2 Measuring Distances Between Celestial Bodies Kepler\u2019s Third Law is also used to determine distances in astronomical units (AU) within a solar system. If the orbital period of a planet is known, we can solve for \\(r\\) : \\[ r^3 = \\frac{G M}{4\\pi^2} T^2 \\] This allows astronomers to determine the average orbital radius (semi-major axis) for planets or satellites without needing direct distance measurements. Application Example: If a satellite is in orbit around Earth and its period \\(T\\) is measured to be 90 minutes, the orbital radius \\(r\\) (distance from the Earth's center) can be calculated, assuming Earth's mass \\(M \\approx 5.97 \\times 10^{24} \\, \\text{kg}\\) . 2.3 Understanding Gravitational Interactions in Planetary Systems Kepler's Third Law reveals essential truths about the gravitational structure and dynamics of planetary systems: Orbital hierarchy : Bodies farther from the central mass have longer periods, implying a natural ordering of planetary orbits. Stability analysis : Deviations from \\(T^2 \\propto r^3\\) can indicate perturbations or gravitational influences from other nearby bodies. Mass distribution : In binary systems or exoplanet systems, the law helps in estimating the combined mass of the orbiting and central objects, particularly when both have non-negligible mass. Binary System Case: If two stars orbit their common center of mass, a modified version of Kepler's law applies: \\[ T^2 = \\frac{4\\pi^2 a^3}{G (M_1 + M_2)} \\] Where \\(a\\) is the semi-major axis of the relative orbit, and \\(M_1\\) , \\(M_2\\) are the masses of the two stars. 2.4 Broader Significance The law underpins space mission planning , such as orbital insertions and transfers. It allows scaling from solar system mechanics to galactic dynamics . Provides the foundation for mass-luminosity relations , exoplanet discovery via transit and radial velocity methods , and estimates of dark matter from galactic rotation curves. 3. Real-World Analysis 3.1 The Moon\u2019s Orbit Around Earth The Moon's orbit provides a practical example of Kepler's Third Law. Key parameters of the Moon's orbit are: Orbital Period : The Moon completes one orbit around Earth in approximately 27.32166 days (sidereal month) :contentReference[oaicite:0]{index=0}. Mean Orbital Radius : The average distance from the Moon to Earth's center is about 384,400 km :contentReference[oaicite:1]{index=1}. Using these values, we can calculate the ratio: \\[ \\frac{r^3}{T^2} = \\frac{(384,400\\ \\text{km})^3}{(27.32166\\ \\text{days})^2} \\] This ratio should be consistent with the gravitational parameter for Earth, confirming the applicability of Kepler's Third Law. 3.2 Planetary Orbits in the Solar System Kepler's Third Law can be examined across the planets in our Solar System. The law states: \\[ \\frac{a^3}{T^2} = \\text{constant} \\] Where: - \\(a\\) is the semi-major axis (average orbital radius) - \\(T\\) is the orbital period The following table presents the semi-major axes and orbital periods of the planets: Planet Semi-Major Axis (AU) Orbital Period (days) Mercury 0.38710 87.969 Venus 0.72333 224.701 Earth 1.00000 365.256 Mars 1.52366 686.980 Jupiter 5.20336 4332.820 Saturn 9.53707 10759.20 Uranus 19.1913 30687.15 Neptune 30.0690 60190.03 Calculating \\(\\frac{a^3}{T^2}\\) for each planet yields values that are remarkably consistent, supporting Kepler's Third Law :contentReference[oaicite:2]{index=2}. 3.3 Alignment with Kepler\u2019s Third Law To assess the alignment with Kepler's Third Law, we compute the ratio \\(\\frac{a^3}{T^2}\\) for each planet: \\[ \\frac{a^3}{T^2} \\approx 7.5 \\times 10^{-6}\\ \\text{AU}^3/\\text{day}^2 \\] This consistency across different planets indicates that the square of the orbital period is indeed proportional to the cube of the semi-major axis, as Kepler's Third Law predicts. Code and Plots Kepler's Third Law # Import necessary libraries import matplotlib.pyplot as plt import numpy as np # Define the semi-major axes (in AU) and orbital periods (in Earth years) for the planets planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'] semi_major_axes = [0.387, 0.723, 1.000, 1.524, 5.203, 9.539, 19.191, 30.070] # Semi-major axes in AU orbital_periods = [0.241, 0.615, 1.000, 1.881, 11.862, 29.457, 84.011, 164.791] # Orbital periods in Earth years # Compute log10(r^3) and log10(T^2) log_r_cubed = np.log10(np.array(semi_major_axes)**3) log_T_squared = np.log10(np.array(orbital_periods)**2) # Perform linear regression to get the best-fit line coeffs = np.polyfit(log_r_cubed, log_T_squared, 1) slope, intercept = coeffs best_fit_line = slope * log_r_cubed + intercept # Create the scatter plot plt.figure(figsize=(10, 6)) plt.scatter(log_r_cubed, log_T_squared, color='blue', label='Planet Data') # Plot the best-fit line (Kepler's Law line) plt.plot(log_r_cubed, best_fit_line, color='red', linestyle='--', label=f'Best Fit: $y = {slope:.2f}x + {intercept:.2f}$') # Annotate each data point with the planet name for i, planet in enumerate(planets): plt.annotate(planet, (log_r_cubed[i], log_T_squared[i]), textcoords=\"offset points\", xytext=(5,5), ha='left', va='bottom') # Customize the plot plt.title(\"Kepler's Third Law: $T^2$ vs. $r^3$ (Log Scale)\") plt.xlabel('$\\log_{10}(r^3)$ (AU$^3$)') plt.ylabel('$\\log_{10}(T^2)$ (yr$^2$)') plt.grid(True, which=\"both\", ls=\"--\", alpha=0.6) plt.legend() plt.tight_layout() # Display the plot plt.show() Planet orbiting around the star # Step 1: Install imageio for saving GIFs (only needed once in Colab) !pip install imageio imageio-ffmpeg --quiet import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation import imageio from google.colab import files # Step 2: Set up simulation parameters num_frames = 100 G = 1 # Gravitational constant (simplified) M = 1 # Mass of the star omega = 0.1 # Angular velocity # Generate time frames theta = np.linspace(0, 2 * np.pi, num_frames) # Circular orbit coordinates for the planet def orbit(theta): r = 5 # radius of orbit x = r * np.cos(theta) y = r * np.sin(theta) return x, y # Step 3: Create figure and axis fig, ax = plt.subplots(figsize=(6, 6)) ax.set_aspect('equal') ax.set_xlim(-10, 10) ax.set_ylim(-10, 10) ax.set_facecolor('black') plt.axis('off') # Star at center star, = ax.plot(0, 0, 'yo', markersize=15, label='Star') # Planet planet, = ax.plot([], [], 'bo', markersize=8, label='Planet') # Orbit path orbit_path, = ax.plot([], [], 'gray', linestyle='--', linewidth=1) # Step 4: Update function for animation def update(frame): x_p, y_p = orbit(theta[frame]) planet.set_data([x_p], [y_p]) # Wrap in list to make it a sequence # Draw full orbit path only after first frame if frame > 0: x_orbit = [orbit(theta[i])[0] for i in range(frame)] y_orbit = [orbit(theta[i])[1] for i in range(frame)] orbit_path.set_data(x_orbit, y_orbit) else: orbit_path.set_data([], []) return planet, orbit_path, # Step 5: Animate ani = FuncAnimation(fig, update, frames=num_frames, interval=50, blit=True) # Step 6: Save as GIF filename = 'orbit_animation.gif' ani.save(filename, writer='pillow', fps=20) # Step 7: Download the GIF files.download(filename) Colab Colab","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-derivation","text":"","title":"1. Theoretical Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#11-introduction","text":"To derive Kepler\u2019s Third Law for circular orbits, we begin with Newton's Law of Universal Gravitation and centripetal force . We aim to find a mathematical relationship between the orbital period squared and the orbital radius cubed , i.e., \\[ T^2 \\propto r^3 \\] This derivation assumes the orbiting body has negligible mass compared to the central mass and follows a perfectly circular orbit .","title":"1.1 Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_1/#12-newtons-law-of-universal-gravitation","text":"Newton\u2019s law states that the gravitational force \\(F_g\\) between two point masses \\(m_1\\) and \\(m_2\\) separated by a distance \\(r\\) is given by: \\[ F_g = G \\frac{m_1 m_2}{r^2} \\] Where: - \\(F_g\\) is the gravitational force - \\(G\\) is the universal gravitational constant ( \\(6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2\\) ) - \\(r\\) is the separation between the centers of mass","title":"1.2 Newton's Law of Universal Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#13-centripetal-force-in-circular-motion","text":"For an object of mass \\(m\\) moving with orbital speed \\(v\\) in a circle of radius \\(r\\) , the required centripetal force \\(F_c\\) is: \\[ F_c = \\frac{m v^2}{r} \\] In a stable circular orbit, this force is provided entirely by gravity. Therefore: \\[ F_g = F_c \\] Substituting: \\[ G \\frac{M m}{r^2} = \\frac{m v^2}{r} \\] Cancel \\(m\\) (mass of the orbiting body) from both sides: \\[ G \\frac{M}{r^2} = \\frac{v^2}{r} \\] Multiply both sides by \\(r\\) : \\[ G \\frac{M}{r} = v^2 \\]","title":"1.3 Centripetal Force in Circular Motion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#14-orbital-period-and-velocity","text":"The orbital period \\(T\\) is the time it takes for one full orbit. For a circular orbit, the distance traveled in one period is the circumference \\(2\\pi r\\) : \\[ v = \\frac{2\\pi r}{T} \\] Substitute this into the previous equation: \\[ G \\frac{M}{r} = \\left( \\frac{2\\pi r}{T} \\right)^2 \\] Expand the right-hand side: \\[ G \\frac{M}{r} = \\frac{4\\pi^2 r^2}{T^2} \\] Multiply both sides by \\(T^2\\) : \\[ G M T^2 = 4\\pi^2 r^3 \\] Finally, solve for \\(T^2\\) : \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\]","title":"1.4 Orbital Period and Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_1/#15-final-form-of-keplers-third-law","text":"This is the mathematical expression of Kepler\u2019s Third Law for circular orbits: \\[ T^2 \\propto r^3 \\] The constant of proportionality is \\(\\frac{4\\pi^2}{G M}\\) , which depends on the mass \\(M\\) of the central object.","title":"1.5 Final Form of Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-astronomical-implications","text":"","title":"2. Astronomical Implications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#21-determining-planetary-masses-using-keplers-third-law","text":"Kepler\u2019s Third Law, when combined with Newtonian mechanics, allows us to calculate the mass of a central celestial body \u2014such as a planet or star\u2014by observing the motion of an orbiting object. From the derived formula: \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] Rearranging to solve for \\(M\\) : \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] Where: - \\(r\\) is the orbital radius - \\(T\\) is the orbital period - \\(M\\) is the mass of the central body - \\(G\\) is the gravitational constant Example : By observing a moon orbiting a planet and measuring its orbital radius and period, we can calculate the planet\u2019s mass precisely.","title":"2.1 Determining Planetary Masses Using Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#22-measuring-distances-between-celestial-bodies","text":"Kepler\u2019s Third Law is also used to determine distances in astronomical units (AU) within a solar system. If the orbital period of a planet is known, we can solve for \\(r\\) : \\[ r^3 = \\frac{G M}{4\\pi^2} T^2 \\] This allows astronomers to determine the average orbital radius (semi-major axis) for planets or satellites without needing direct distance measurements.","title":"2.2 Measuring Distances Between Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_1/#application-example","text":"If a satellite is in orbit around Earth and its period \\(T\\) is measured to be 90 minutes, the orbital radius \\(r\\) (distance from the Earth's center) can be calculated, assuming Earth's mass \\(M \\approx 5.97 \\times 10^{24} \\, \\text{kg}\\) .","title":"Application Example:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#23-understanding-gravitational-interactions-in-planetary-systems","text":"Kepler's Third Law reveals essential truths about the gravitational structure and dynamics of planetary systems: Orbital hierarchy : Bodies farther from the central mass have longer periods, implying a natural ordering of planetary orbits. Stability analysis : Deviations from \\(T^2 \\propto r^3\\) can indicate perturbations or gravitational influences from other nearby bodies. Mass distribution : In binary systems or exoplanet systems, the law helps in estimating the combined mass of the orbiting and central objects, particularly when both have non-negligible mass.","title":"2.3 Understanding Gravitational Interactions in Planetary Systems"},{"location":"1%20Physics/2%20Gravity/Problem_1/#binary-system-case","text":"If two stars orbit their common center of mass, a modified version of Kepler's law applies: \\[ T^2 = \\frac{4\\pi^2 a^3}{G (M_1 + M_2)} \\] Where \\(a\\) is the semi-major axis of the relative orbit, and \\(M_1\\) , \\(M_2\\) are the masses of the two stars.","title":"Binary System Case:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#24-broader-significance","text":"The law underpins space mission planning , such as orbital insertions and transfers. It allows scaling from solar system mechanics to galactic dynamics . Provides the foundation for mass-luminosity relations , exoplanet discovery via transit and radial velocity methods , and estimates of dark matter from galactic rotation curves.","title":"2.4 Broader Significance"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-analysis","text":"","title":"3. Real-World Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_1/#31-the-moons-orbit-around-earth","text":"The Moon's orbit provides a practical example of Kepler's Third Law. Key parameters of the Moon's orbit are: Orbital Period : The Moon completes one orbit around Earth in approximately 27.32166 days (sidereal month) :contentReference[oaicite:0]{index=0}. Mean Orbital Radius : The average distance from the Moon to Earth's center is about 384,400 km :contentReference[oaicite:1]{index=1}. Using these values, we can calculate the ratio: \\[ \\frac{r^3}{T^2} = \\frac{(384,400\\ \\text{km})^3}{(27.32166\\ \\text{days})^2} \\] This ratio should be consistent with the gravitational parameter for Earth, confirming the applicability of Kepler's Third Law.","title":"3.1 The Moon\u2019s Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#32-planetary-orbits-in-the-solar-system","text":"Kepler's Third Law can be examined across the planets in our Solar System. The law states: \\[ \\frac{a^3}{T^2} = \\text{constant} \\] Where: - \\(a\\) is the semi-major axis (average orbital radius) - \\(T\\) is the orbital period The following table presents the semi-major axes and orbital periods of the planets: Planet Semi-Major Axis (AU) Orbital Period (days) Mercury 0.38710 87.969 Venus 0.72333 224.701 Earth 1.00000 365.256 Mars 1.52366 686.980 Jupiter 5.20336 4332.820 Saturn 9.53707 10759.20 Uranus 19.1913 30687.15 Neptune 30.0690 60190.03 Calculating \\(\\frac{a^3}{T^2}\\) for each planet yields values that are remarkably consistent, supporting Kepler's Third Law :contentReference[oaicite:2]{index=2}.","title":"3.2 Planetary Orbits in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#33-alignment-with-keplers-third-law","text":"To assess the alignment with Kepler's Third Law, we compute the ratio \\(\\frac{a^3}{T^2}\\) for each planet: \\[ \\frac{a^3}{T^2} \\approx 7.5 \\times 10^{-6}\\ \\text{AU}^3/\\text{day}^2 \\] This consistency across different planets indicates that the square of the orbital period is indeed proportional to the cube of the semi-major axis, as Kepler's Third Law predicts.","title":"3.3 Alignment with Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#code-and-plots","text":"","title":"Code and Plots"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law","text":"# Import necessary libraries import matplotlib.pyplot as plt import numpy as np # Define the semi-major axes (in AU) and orbital periods (in Earth years) for the planets planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'] semi_major_axes = [0.387, 0.723, 1.000, 1.524, 5.203, 9.539, 19.191, 30.070] # Semi-major axes in AU orbital_periods = [0.241, 0.615, 1.000, 1.881, 11.862, 29.457, 84.011, 164.791] # Orbital periods in Earth years # Compute log10(r^3) and log10(T^2) log_r_cubed = np.log10(np.array(semi_major_axes)**3) log_T_squared = np.log10(np.array(orbital_periods)**2) # Perform linear regression to get the best-fit line coeffs = np.polyfit(log_r_cubed, log_T_squared, 1) slope, intercept = coeffs best_fit_line = slope * log_r_cubed + intercept # Create the scatter plot plt.figure(figsize=(10, 6)) plt.scatter(log_r_cubed, log_T_squared, color='blue', label='Planet Data') # Plot the best-fit line (Kepler's Law line) plt.plot(log_r_cubed, best_fit_line, color='red', linestyle='--', label=f'Best Fit: $y = {slope:.2f}x + {intercept:.2f}$') # Annotate each data point with the planet name for i, planet in enumerate(planets): plt.annotate(planet, (log_r_cubed[i], log_T_squared[i]), textcoords=\"offset points\", xytext=(5,5), ha='left', va='bottom') # Customize the plot plt.title(\"Kepler's Third Law: $T^2$ vs. $r^3$ (Log Scale)\") plt.xlabel('$\\log_{10}(r^3)$ (AU$^3$)') plt.ylabel('$\\log_{10}(T^2)$ (yr$^2$)') plt.grid(True, which=\"both\", ls=\"--\", alpha=0.6) plt.legend() plt.tight_layout() # Display the plot plt.show()","title":"Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#planet-orbiting-around-the-star","text":"# Step 1: Install imageio for saving GIFs (only needed once in Colab) !pip install imageio imageio-ffmpeg --quiet import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation import imageio from google.colab import files # Step 2: Set up simulation parameters num_frames = 100 G = 1 # Gravitational constant (simplified) M = 1 # Mass of the star omega = 0.1 # Angular velocity # Generate time frames theta = np.linspace(0, 2 * np.pi, num_frames) # Circular orbit coordinates for the planet def orbit(theta): r = 5 # radius of orbit x = r * np.cos(theta) y = r * np.sin(theta) return x, y # Step 3: Create figure and axis fig, ax = plt.subplots(figsize=(6, 6)) ax.set_aspect('equal') ax.set_xlim(-10, 10) ax.set_ylim(-10, 10) ax.set_facecolor('black') plt.axis('off') # Star at center star, = ax.plot(0, 0, 'yo', markersize=15, label='Star') # Planet planet, = ax.plot([], [], 'bo', markersize=8, label='Planet') # Orbit path orbit_path, = ax.plot([], [], 'gray', linestyle='--', linewidth=1) # Step 4: Update function for animation def update(frame): x_p, y_p = orbit(theta[frame]) planet.set_data([x_p], [y_p]) # Wrap in list to make it a sequence # Draw full orbit path only after first frame if frame > 0: x_orbit = [orbit(theta[i])[0] for i in range(frame)] y_orbit = [orbit(theta[i])[1] for i in range(frame)] orbit_path.set_data(x_orbit, y_orbit) else: orbit_path.set_data([], []) return planet, orbit_path, # Step 5: Animate ani = FuncAnimation(fig, update, frames=num_frames, interval=50, blit=True) # Step 6: Save as GIF filename = 'orbit_animation.gif' ani.save(filename, writer='pillow', fps=20) # Step 7: Download the GIF files.download(filename)","title":"Planet orbiting around the star"},{"location":"1%20Physics/2%20Gravity/Problem_1/#colab","text":"Colab","title":"Colab"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 1. Research and Definitions 1.1 First Cosmic Velocity (Orbital Velocity) The first cosmic velocity is the minimum speed an object must have to maintain a stable circular orbit near the surface of a celestial body, without any propulsion, purely under the influence of gravity. This velocity is derived from the condition where the centripetal force equals the gravitational force : \\[ \\frac{mv^2}{r} = \\frac{G M m}{r^2} \\] Solving for \\(v\\) gives: \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\] Where: - \\(v_1\\) is the first cosmic velocity, - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the celestial body, - \\(r\\) is the radius from the center of the body. Physical Significance : This velocity allows satellites to orbit without falling back to the surface due to gravity. 1.2 Second Cosmic Velocity (Escape Velocity) The second cosmic velocity is the minimum speed required for an object to completely escape the gravitational field of a celestial body, assuming no other forces act on it. Derived from conservation of energy: \\[ \\frac{1}{2}mv^2 = \\frac{G M m}{r} \\] Which leads to: \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] Physical Meaning : This is the threshold speed needed to overcome gravitational binding energy and move to infinity with zero residual velocity. 1.3 Third Cosmic Velocity (Interstellar Escape Velocity) The third cosmic velocity refers to the speed required to escape the gravitational influence of the entire star system (e.g., the Sun and its planets). It typically involves escaping both the Earth and the Sun's gravitational fields. Assuming the object is first launched from Earth into solar orbit, the third cosmic velocity (relative to the Sun) is: \\[ v_3 = \\sqrt{2GM_{\\odot} \\left( \\frac{1}{r_{\\text{Earth}}} - \\frac{1}{r_{\\infty}} \\right)} \\] Since \\(r_{\\infty} \\to \\infty\\) , it simplifies to: \\[ v_3 = \\sqrt{\\frac{2GM_{\\odot}}{r_{\\text{Earth}}}} \\] Role : This is the minimum velocity required to leave the entire Solar System, for example, to send a probe into interstellar space. 1.4 Relevant Physical Parameters Parameter Earth Mars Jupiter Mass ( \\(M\\) ) \\(5.972 \\times 10^{24}\\) kg \\(6.417 \\times 10^{23}\\) kg \\(1.898 \\times 10^{27}\\) kg Radius ( \\(r\\) ) \\(6.371 \\times 10^6\\) m \\(3.390 \\times 10^6\\) m \\(6.991 \\times 10^7\\) m Gravitational Constant ( \\(G\\) ) \\(6.67430 \\times 10^{-11} \\ \\mathrm{m}^3 \\, \\mathrm{kg}^{-1} \\, \\mathrm{s}^{-2}\\) Escape Velocity ( \\(v_2\\) ) \\(11.2 \\ \\mathrm{km/s}\\) \\(5.0 \\ \\mathrm{km/s}\\) \\(59.5 \\ \\mathrm{km/s}\\) Orbital Velocity ( \\(v_1\\) ) \\(7.9 \\ \\mathrm{km/s}\\) \\(3.6 \\ \\mathrm{km/s}\\) \\(42.1 \\ \\mathrm{km/s}\\) Notes: These velocities assume no atmosphere and a spherically symmetric mass distribution. The third cosmic velocity requires considering orbital mechanics and solar system dynamics. 2. Mathematical Analysis 2.1 Derivation of the First Cosmic Velocity We consider a body of mass \\(m\\) in a circular orbit at radius \\(r\\) around a celestial body of mass \\(M\\) . The gravitational force provides the necessary centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v_1^2}{r} \\] Canceling \\(m\\) and solving for \\(v_1\\) : \\[ v_1^2 = \\frac{G M}{r} \\] Thus, the first cosmic velocity is: \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\] Affected Parameters : - \\(G\\) : gravitational constant - \\(M\\) : mass of the central body - \\(r\\) : radius from the center of the body 2.2 Derivation of the Second Cosmic Velocity To escape the gravitational field of a body, the total mechanical energy must be zero or positive. Initial energy (at the surface): \\[ E = \\frac{1}{2}mv^2 - \\frac{G M m}{r} \\] Set \\(E = 0\\) (the escape condition), and solve for \\(v\\) : \\[ \\frac{1}{2}mv_2^2 = \\frac{G M m}{r} \\] Canceling \\(m\\) : \\[ v_2 = \\sqrt{\\frac{2 G M}{r}} \\] Affected Parameters : - \\(G\\) : gravitational constant - \\(M\\) : mass of the celestial body - \\(r\\) : radius from the center of the body 2.3 Derivation of the Third Cosmic Velocity The third cosmic velocity is the minimum speed required to escape the gravitational field of the entire star system , typically from a planet's orbit around its star. Assume: - Escape from the Sun's gravity - Initial position: Earth's orbit ( \\(r = r_{\\text{Earth}}\\) ) - Final position: \\(r \\to \\infty\\) - Planet's orbital velocity: \\(v_{\\text{orbit}} = \\sqrt{\\frac{G M_{\\odot}}{r}}\\) We use energy conservation in the heliocentric frame: Total mechanical energy for escape from orbit: \\[ E = \\frac{1}{2}mv^2 - \\frac{G M_{\\odot} m}{r} \\] Set \\(E = 0\\) (just escape to infinity), solve for \\(v\\) : \\[ v_3 = \\sqrt{\\frac{2 G M_{\\odot}}{r}} \\] But a body already in orbit has an initial orbital velocity \\(v_{\\text{orbit}} = \\sqrt{\\frac{G M_{\\odot}}{r}}\\) . To escape, we must add \\(\\Delta v\\) such that: \\[ v_{\\text{total}}^2 = v_{\\text{orbit}}^2 + (\\Delta v)^2 = v_3^2 \\] Then: \\[ \\Delta v = \\sqrt{v_3^2 - v_{\\text{orbit}}^2} = \\sqrt{ \\frac{2GM_{\\odot}}{r} - \\frac{GM_{\\odot}}{r} } = \\sqrt{ \\frac{GM_{\\odot}}{r} } \\] Thus: \\[ \\Delta v = v_{\\text{orbit}} = \\sqrt{ \\frac{GM_{\\odot}}{r} } \\] So, to escape the Solar System from Earth's orbit, a probe must double its heliocentric orbital energy , requiring an increase in speed by: \\[ \\Delta v = \\sqrt{ \\frac{GM_{\\odot}}{r} } \\] Affected Parameters : - \\(G\\) : gravitational constant - \\(M_{\\odot}\\) : mass of the Sun - \\(r\\) : distance from the star (e.g., Earth's orbital radius) Summary of Velocity Dependencies Velocity Type Formula Depends On First Cosmic Velocity \\(v_1 = \\sqrt{\\frac{GM}{r}}\\) \\(M\\) , \\(r\\) Second Cosmic Velocity \\(v_2 = \\sqrt{\\frac{2GM}{r}}\\) \\(M\\) , \\(r\\) Third Cosmic Velocity \\(v_3 = \\sqrt{\\frac{2GM_{\\odot}}{r}}\\) \\(M_{\\odot}\\) , \\(r\\) (from the star) 3. Data Collection Accurate, up-to-date values for planetary and solar parameters are provided below. These are used to compute the first , second , and third cosmic velocities for Earth, Mars, and Jupiter. 3.1 Universal Gravitational Constant Gravitational Constant ( \\(G\\) ): \\[ G = 6.67430 \\times 10^{-11} \\ \\mathrm{m}^3\\,\\mathrm{kg}^{-1}\\,\\mathrm{s}^{-2} \\] 3.2 Parameters and Computed Velocities Earth Mass ( \\(M_{\\oplus}\\) ): \\[ M_{\\oplus} = 5.97219 \\times 10^{24} \\ \\mathrm{kg} \\] Radius ( \\(R_{\\oplus}\\) ): \\[ R_{\\oplus} = 6.371 \\times 10^6 \\ \\mathrm{m} \\] First Cosmic Velocity ( \\(v_1\\) ): \\[ v_1 = \\sqrt{\\frac{GM}{R}} = \\sqrt{\\frac{6.67430 \\times 10^{-11} \\cdot 5.97219 \\times 10^{24}}{6.371 \\times 10^6}} \\approx 7.91 \\ \\mathrm{km/s} \\] Second Cosmic Velocity ( \\(v_2\\) ): \\[ v_2 = \\sqrt{\\frac{2GM}{R}} \\approx 11.2 \\ \\mathrm{km/s} \\] Third Cosmic Velocity ( \\(v_3\\) ): \\[ v_3 = \\sqrt{ \\frac{2 G M_{\\odot} }{ r_{\\text{Earth-Sun}} } } \\approx 42.1 \\ \\mathrm{km/s} \\] Mars Mass ( \\(M_{\\text{Mars}}\\) ): \\[ M_{\\text{Mars}} = 6.4171 \\times 10^{23} \\ \\mathrm{kg} \\] Radius ( \\(R_{\\text{Mars}}\\) ): \\[ R_{\\text{Mars}} = 3.3895 \\times 10^6 \\ \\mathrm{m} \\] First Cosmic Velocity ( \\(v_1\\) ): \\[ v_1 \\approx 3.55 \\ \\mathrm{km/s} \\] Second Cosmic Velocity ( \\(v_2\\) ): \\[ v_2 \\approx 5.03 \\ \\mathrm{km/s} \\] Third Cosmic Velocity from Mars Orbit (approximate, assuming Mars' orbital radius \\(\\approx 2.279 \\times 10^{11} \\ \\mathrm{m}\\) ): \\[ v_3 \\approx \\sqrt{ \\frac{2 G M_{\\odot}}{r_{\\text{Mars-Sun}}} } \\approx 34.1 \\ \\mathrm{km/s} \\] Jupiter Mass ( \\(M_{\\text{Jupiter}}\\) ): \\[ M_{\\text{Jupiter}} = 1.89813 \\times 10^{27} \\ \\mathrm{kg} \\] Radius ( \\(R_{\\text{Jupiter}}\\) ): \\[ R_{\\text{Jupiter}} = 6.9911 \\times 10^7 \\ \\mathrm{m} \\] First Cosmic Velocity ( \\(v_1\\) ): \\[ v_1 \\approx 42.1 \\ \\mathrm{km/s} \\] Second Cosmic Velocity ( \\(v_2\\) ): \\[ v_2 \\approx 59.5 \\ \\mathrm{km/s} \\] Third Cosmic Velocity from Jupiter Orbit (Jupiter's average orbital radius \\(\\approx 7.785 \\times 10^{11} \\ \\mathrm{m}\\) ): \\[ v_3 \\approx 18.5 \\ \\mathrm{km/s} \\] 3.3 Solar Parameters Mass of the Sun ( \\(M_{\\odot}\\) ): \\[ M_{\\odot} = 1.9885 \\times 10^{30} \\ \\mathrm{kg} \\] Earth-Sun Distance (mean orbital radius): \\[ r_{\\text{Earth-Sun}} = 1.496 \\times 10^{11} \\ \\mathrm{m} \\] 3.4 Summary Table: Computed Cosmic Velocities Body \\(v_1\\) (km/s) \\(v_2\\) (km/s) \\(v_3\\) (km/s) Earth 7.91 11.2 42.1 Mars 3.55 5.03 34.1 Jupiter 42.1 59.5 18.5 Note: The third cosmic velocity decreases with distance from the Sun despite a planet\u2019s own higher gravity, since the Sun\u2019s gravitational pull weakens with radius. Code and Plots def first_cosmic_velocity(M, R): return np.sqrt(G * M / R) def second_cosmic_velocity(M, R): return np.sqrt(2 * G * M / R) def third_cosmic_velocity(r_from_sun): return np.sqrt(2 * G * M_sun / r_from_sun) # -- COMPUTATION -------------------------------------------------- results = {} for name, data in bodies.items(): M = data['mass'] R = data['radius'] r_orbit = r_sun.get(name, r_sun['Earth']) # use Earth's orbit for Moon v1 = first_cosmic_velocity(M, R) / 1e3 # m/s \u2192 km/s v2 = second_cosmic_velocity(M, R) / 1e3 v3 = third_cosmic_velocity(r_orbit) / 1e3 results[name] = {'v1': v1, 'v2': v2, 'v3': v3} # -- VALIDATION (optional) ---------------------------------------- print(\"Earth escape velocity (expected \u2248 11.2 km/s):\", round(results['Earth']['v2'], 2), \"km/s\") # -- VISUALIZATION ------------------------------------------------ labels = list(results.keys()) v1_vals = [results[k]['v1'] for k in labels] v2_vals = [results[k]['v2'] for k in labels] v3_vals = [results[k]['v3'] for k in labels] x = np.arange(len(labels)) width = 0.25 plt.figure(figsize=(10,6)) plt.bar(x - width, v1_vals, width, label='1st Cosmic Velocity') plt.bar(x, v2_vals, width, label='2nd Cosmic Velocity') plt.bar(x + width, v3_vals, width, label='3rd Cosmic Velocity') plt.ylabel('Velocity (km/s)') plt.title('Comparison of Cosmic Velocities') plt.xticks(x, labels) plt.legend() plt.grid(True, linestyle='--', alpha=0.5) plt.tight_layout() plt.show() Colab Colab","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-research-and-definitions","text":"","title":"1. Research and Definitions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#11-first-cosmic-velocity-orbital-velocity","text":"The first cosmic velocity is the minimum speed an object must have to maintain a stable circular orbit near the surface of a celestial body, without any propulsion, purely under the influence of gravity. This velocity is derived from the condition where the centripetal force equals the gravitational force : \\[ \\frac{mv^2}{r} = \\frac{G M m}{r^2} \\] Solving for \\(v\\) gives: \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\] Where: - \\(v_1\\) is the first cosmic velocity, - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the celestial body, - \\(r\\) is the radius from the center of the body. Physical Significance : This velocity allows satellites to orbit without falling back to the surface due to gravity.","title":"1.1 First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#12-second-cosmic-velocity-escape-velocity","text":"The second cosmic velocity is the minimum speed required for an object to completely escape the gravitational field of a celestial body, assuming no other forces act on it. Derived from conservation of energy: \\[ \\frac{1}{2}mv^2 = \\frac{G M m}{r} \\] Which leads to: \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] Physical Meaning : This is the threshold speed needed to overcome gravitational binding energy and move to infinity with zero residual velocity.","title":"1.2 Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#13-third-cosmic-velocity-interstellar-escape-velocity","text":"The third cosmic velocity refers to the speed required to escape the gravitational influence of the entire star system (e.g., the Sun and its planets). It typically involves escaping both the Earth and the Sun's gravitational fields. Assuming the object is first launched from Earth into solar orbit, the third cosmic velocity (relative to the Sun) is: \\[ v_3 = \\sqrt{2GM_{\\odot} \\left( \\frac{1}{r_{\\text{Earth}}} - \\frac{1}{r_{\\infty}} \\right)} \\] Since \\(r_{\\infty} \\to \\infty\\) , it simplifies to: \\[ v_3 = \\sqrt{\\frac{2GM_{\\odot}}{r_{\\text{Earth}}}} \\] Role : This is the minimum velocity required to leave the entire Solar System, for example, to send a probe into interstellar space.","title":"1.3 Third Cosmic Velocity (Interstellar Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#14-relevant-physical-parameters","text":"Parameter Earth Mars Jupiter Mass ( \\(M\\) ) \\(5.972 \\times 10^{24}\\) kg \\(6.417 \\times 10^{23}\\) kg \\(1.898 \\times 10^{27}\\) kg Radius ( \\(r\\) ) \\(6.371 \\times 10^6\\) m \\(3.390 \\times 10^6\\) m \\(6.991 \\times 10^7\\) m Gravitational Constant ( \\(G\\) ) \\(6.67430 \\times 10^{-11} \\ \\mathrm{m}^3 \\, \\mathrm{kg}^{-1} \\, \\mathrm{s}^{-2}\\) Escape Velocity ( \\(v_2\\) ) \\(11.2 \\ \\mathrm{km/s}\\) \\(5.0 \\ \\mathrm{km/s}\\) \\(59.5 \\ \\mathrm{km/s}\\) Orbital Velocity ( \\(v_1\\) ) \\(7.9 \\ \\mathrm{km/s}\\) \\(3.6 \\ \\mathrm{km/s}\\) \\(42.1 \\ \\mathrm{km/s}\\)","title":"1.4 Relevant Physical Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#notes","text":"These velocities assume no atmosphere and a spherically symmetric mass distribution. The third cosmic velocity requires considering orbital mechanics and solar system dynamics.","title":"Notes:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-mathematical-analysis","text":"","title":"2. Mathematical Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_2/#21-derivation-of-the-first-cosmic-velocity","text":"We consider a body of mass \\(m\\) in a circular orbit at radius \\(r\\) around a celestial body of mass \\(M\\) . The gravitational force provides the necessary centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v_1^2}{r} \\] Canceling \\(m\\) and solving for \\(v_1\\) : \\[ v_1^2 = \\frac{G M}{r} \\] Thus, the first cosmic velocity is: \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\] Affected Parameters : - \\(G\\) : gravitational constant - \\(M\\) : mass of the central body - \\(r\\) : radius from the center of the body","title":"2.1 Derivation of the First Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#22-derivation-of-the-second-cosmic-velocity","text":"To escape the gravitational field of a body, the total mechanical energy must be zero or positive. Initial energy (at the surface): \\[ E = \\frac{1}{2}mv^2 - \\frac{G M m}{r} \\] Set \\(E = 0\\) (the escape condition), and solve for \\(v\\) : \\[ \\frac{1}{2}mv_2^2 = \\frac{G M m}{r} \\] Canceling \\(m\\) : \\[ v_2 = \\sqrt{\\frac{2 G M}{r}} \\] Affected Parameters : - \\(G\\) : gravitational constant - \\(M\\) : mass of the celestial body - \\(r\\) : radius from the center of the body","title":"2.2 Derivation of the Second Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#23-derivation-of-the-third-cosmic-velocity","text":"The third cosmic velocity is the minimum speed required to escape the gravitational field of the entire star system , typically from a planet's orbit around its star. Assume: - Escape from the Sun's gravity - Initial position: Earth's orbit ( \\(r = r_{\\text{Earth}}\\) ) - Final position: \\(r \\to \\infty\\) - Planet's orbital velocity: \\(v_{\\text{orbit}} = \\sqrt{\\frac{G M_{\\odot}}{r}}\\) We use energy conservation in the heliocentric frame: Total mechanical energy for escape from orbit: \\[ E = \\frac{1}{2}mv^2 - \\frac{G M_{\\odot} m}{r} \\] Set \\(E = 0\\) (just escape to infinity), solve for \\(v\\) : \\[ v_3 = \\sqrt{\\frac{2 G M_{\\odot}}{r}} \\] But a body already in orbit has an initial orbital velocity \\(v_{\\text{orbit}} = \\sqrt{\\frac{G M_{\\odot}}{r}}\\) . To escape, we must add \\(\\Delta v\\) such that: \\[ v_{\\text{total}}^2 = v_{\\text{orbit}}^2 + (\\Delta v)^2 = v_3^2 \\] Then: \\[ \\Delta v = \\sqrt{v_3^2 - v_{\\text{orbit}}^2} = \\sqrt{ \\frac{2GM_{\\odot}}{r} - \\frac{GM_{\\odot}}{r} } = \\sqrt{ \\frac{GM_{\\odot}}{r} } \\] Thus: \\[ \\Delta v = v_{\\text{orbit}} = \\sqrt{ \\frac{GM_{\\odot}}{r} } \\] So, to escape the Solar System from Earth's orbit, a probe must double its heliocentric orbital energy , requiring an increase in speed by: \\[ \\Delta v = \\sqrt{ \\frac{GM_{\\odot}}{r} } \\] Affected Parameters : - \\(G\\) : gravitational constant - \\(M_{\\odot}\\) : mass of the Sun - \\(r\\) : distance from the star (e.g., Earth's orbital radius)","title":"2.3 Derivation of the Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#summary-of-velocity-dependencies","text":"Velocity Type Formula Depends On First Cosmic Velocity \\(v_1 = \\sqrt{\\frac{GM}{r}}\\) \\(M\\) , \\(r\\) Second Cosmic Velocity \\(v_2 = \\sqrt{\\frac{2GM}{r}}\\) \\(M\\) , \\(r\\) Third Cosmic Velocity \\(v_3 = \\sqrt{\\frac{2GM_{\\odot}}{r}}\\) \\(M_{\\odot}\\) , \\(r\\) (from the star)","title":"Summary of Velocity Dependencies"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-data-collection","text":"Accurate, up-to-date values for planetary and solar parameters are provided below. These are used to compute the first , second , and third cosmic velocities for Earth, Mars, and Jupiter.","title":"3. Data Collection"},{"location":"1%20Physics/2%20Gravity/Problem_2/#31-universal-gravitational-constant","text":"Gravitational Constant ( \\(G\\) ): \\[ G = 6.67430 \\times 10^{-11} \\ \\mathrm{m}^3\\,\\mathrm{kg}^{-1}\\,\\mathrm{s}^{-2} \\]","title":"3.1 Universal Gravitational Constant"},{"location":"1%20Physics/2%20Gravity/Problem_2/#32-parameters-and-computed-velocities","text":"","title":"3.2 Parameters and Computed Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#earth","text":"Mass ( \\(M_{\\oplus}\\) ): \\[ M_{\\oplus} = 5.97219 \\times 10^{24} \\ \\mathrm{kg} \\] Radius ( \\(R_{\\oplus}\\) ): \\[ R_{\\oplus} = 6.371 \\times 10^6 \\ \\mathrm{m} \\] First Cosmic Velocity ( \\(v_1\\) ): \\[ v_1 = \\sqrt{\\frac{GM}{R}} = \\sqrt{\\frac{6.67430 \\times 10^{-11} \\cdot 5.97219 \\times 10^{24}}{6.371 \\times 10^6}} \\approx 7.91 \\ \\mathrm{km/s} \\] Second Cosmic Velocity ( \\(v_2\\) ): \\[ v_2 = \\sqrt{\\frac{2GM}{R}} \\approx 11.2 \\ \\mathrm{km/s} \\] Third Cosmic Velocity ( \\(v_3\\) ): \\[ v_3 = \\sqrt{ \\frac{2 G M_{\\odot} }{ r_{\\text{Earth-Sun}} } } \\approx 42.1 \\ \\mathrm{km/s} \\]","title":"Earth"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mars","text":"Mass ( \\(M_{\\text{Mars}}\\) ): \\[ M_{\\text{Mars}} = 6.4171 \\times 10^{23} \\ \\mathrm{kg} \\] Radius ( \\(R_{\\text{Mars}}\\) ): \\[ R_{\\text{Mars}} = 3.3895 \\times 10^6 \\ \\mathrm{m} \\] First Cosmic Velocity ( \\(v_1\\) ): \\[ v_1 \\approx 3.55 \\ \\mathrm{km/s} \\] Second Cosmic Velocity ( \\(v_2\\) ): \\[ v_2 \\approx 5.03 \\ \\mathrm{km/s} \\] Third Cosmic Velocity from Mars Orbit (approximate, assuming Mars' orbital radius \\(\\approx 2.279 \\times 10^{11} \\ \\mathrm{m}\\) ): \\[ v_3 \\approx \\sqrt{ \\frac{2 G M_{\\odot}}{r_{\\text{Mars-Sun}}} } \\approx 34.1 \\ \\mathrm{km/s} \\]","title":"Mars"},{"location":"1%20Physics/2%20Gravity/Problem_2/#jupiter","text":"Mass ( \\(M_{\\text{Jupiter}}\\) ): \\[ M_{\\text{Jupiter}} = 1.89813 \\times 10^{27} \\ \\mathrm{kg} \\] Radius ( \\(R_{\\text{Jupiter}}\\) ): \\[ R_{\\text{Jupiter}} = 6.9911 \\times 10^7 \\ \\mathrm{m} \\] First Cosmic Velocity ( \\(v_1\\) ): \\[ v_1 \\approx 42.1 \\ \\mathrm{km/s} \\] Second Cosmic Velocity ( \\(v_2\\) ): \\[ v_2 \\approx 59.5 \\ \\mathrm{km/s} \\] Third Cosmic Velocity from Jupiter Orbit (Jupiter's average orbital radius \\(\\approx 7.785 \\times 10^{11} \\ \\mathrm{m}\\) ): \\[ v_3 \\approx 18.5 \\ \\mathrm{km/s} \\]","title":"Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#33-solar-parameters","text":"Mass of the Sun ( \\(M_{\\odot}\\) ): \\[ M_{\\odot} = 1.9885 \\times 10^{30} \\ \\mathrm{kg} \\] Earth-Sun Distance (mean orbital radius): \\[ r_{\\text{Earth-Sun}} = 1.496 \\times 10^{11} \\ \\mathrm{m} \\]","title":"3.3 Solar Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#34-summary-table-computed-cosmic-velocities","text":"Body \\(v_1\\) (km/s) \\(v_2\\) (km/s) \\(v_3\\) (km/s) Earth 7.91 11.2 42.1 Mars 3.55 5.03 34.1 Jupiter 42.1 59.5 18.5 Note: The third cosmic velocity decreases with distance from the Sun despite a planet\u2019s own higher gravity, since the Sun\u2019s gravitational pull weakens with radius.","title":"3.4 Summary Table: Computed Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#code-and-plots","text":"def first_cosmic_velocity(M, R): return np.sqrt(G * M / R) def second_cosmic_velocity(M, R): return np.sqrt(2 * G * M / R) def third_cosmic_velocity(r_from_sun): return np.sqrt(2 * G * M_sun / r_from_sun) # -- COMPUTATION -------------------------------------------------- results = {} for name, data in bodies.items(): M = data['mass'] R = data['radius'] r_orbit = r_sun.get(name, r_sun['Earth']) # use Earth's orbit for Moon v1 = first_cosmic_velocity(M, R) / 1e3 # m/s \u2192 km/s v2 = second_cosmic_velocity(M, R) / 1e3 v3 = third_cosmic_velocity(r_orbit) / 1e3 results[name] = {'v1': v1, 'v2': v2, 'v3': v3} # -- VALIDATION (optional) ---------------------------------------- print(\"Earth escape velocity (expected \u2248 11.2 km/s):\", round(results['Earth']['v2'], 2), \"km/s\") # -- VISUALIZATION ------------------------------------------------ labels = list(results.keys()) v1_vals = [results[k]['v1'] for k in labels] v2_vals = [results[k]['v2'] for k in labels] v3_vals = [results[k]['v3'] for k in labels] x = np.arange(len(labels)) width = 0.25 plt.figure(figsize=(10,6)) plt.bar(x - width, v1_vals, width, label='1st Cosmic Velocity') plt.bar(x, v2_vals, width, label='2nd Cosmic Velocity') plt.bar(x + width, v3_vals, width, label='3rd Cosmic Velocity') plt.ylabel('Velocity (km/s)') plt.title('Comparison of Cosmic Velocities') plt.xticks(x, labels) plt.legend() plt.grid(True, linestyle='--', alpha=0.5) plt.tight_layout() plt.show()","title":"Code and Plots"},{"location":"1%20Physics/2%20Gravity/Problem_2/#colab","text":"Colab","title":"Colab"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Theoretical Analysis In this section, we derive the equations of motion for orbital mechanics, focusing on Newton\u2019s Law of Gravitation, Kepler\u2019s Laws, and the impact of initial conditions on the trajectory of a spacecraft. 1. Deriving Equations of Motion Using Newton\u2019s Law of Gravitation Newton\u2019s Law of Gravitation gives the force between two masses, which is essential for understanding the motion of objects in space. The gravitational force \\( F \\) between two bodies is given by: \\[ F = G \\frac{m_1 m_2}{r^2} \\] Where: - \\( F \\) is the gravitational force, - \\( G \\) is the gravitational constant ( \\(6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) ), - \\( m_1 \\) and \\( m_2 \\) are the masses of the two bodies, - \\( r \\) is the distance between their centers. From Newton\u2019s second law of motion, the force is also equal to mass times acceleration, i.e., \\[ F = m a \\] Equating the two expressions for \\( F \\) , we get the equation of motion: \\[ m a = G \\frac{m_1 m_2}{r^2} \\] For a mass \\( m \\) orbiting a central body, we can simplify this to: \\[ a = G \\frac{m_1}{r^2} \\] This gives us the acceleration experienced by the orbiting body due to gravitational attraction. 2. Applying Kepler\u2019s Laws to Classify Trajectories Kepler's Laws describe the motion of planets and other celestial bodies under the influence of gravity. Kepler\u2019s First Law: The Law of Ellipses The orbit of a planet (or other object) around a central body is an ellipse, with the central body at one focus. The equation for an ellipse in polar coordinates is: \\[ r(\\theta) = \\frac{a(1 - e^2)}{1 + e \\cos \\theta} \\] Where: - \\( r(\\theta) \\) is the radial distance as a function of the true anomaly \\( \\theta \\) , - \\( a \\) is the semi-major axis, - \\( e \\) is the eccentricity of the ellipse. Kepler\u2019s Second Law: The Law of Equal Areas A line segment joining a planet and the central body sweeps out equal areas during equal intervals of time. This implies that the object moves faster when closer to the central body and slower when farther away. This can be expressed as: \\[ \\frac{dA}{dt} = \\frac{1}{2} r^2 \\frac{d\\theta}{dt} = \\text{constant} \\] Kepler\u2019s Third Law: The Law of Periods The square of the orbital period \\( T \\) is proportional to the cube of the semi-major axis \\( a \\) of the orbit: \\[ T^2 = \\frac{4 \\pi^2 a^3}{G m_1} \\] Where: - \\( T \\) is the orbital period, - \\( a \\) is the semi-major axis of the orbit, - \\( m_1 \\) is the mass of the central body. Using Kepler\u2019s Third Law, we can classify possible trajectories into three types: 1. Elliptical Trajectory An object follows a closed elliptical path, typical for most planets, moons, and satellites. The trajectory is bound. 2. Parabolic Trajectory This is the case for an object that escapes a central body with exactly the escape velocity. The trajectory is unbound and follows a parabolic shape. 3. Hyperbolic Trajectory An object that exceeds the escape velocity follows a hyperbolic trajectory, which is also unbound. 3. Defining Initial Conditions and Their Impact on Trajectory Types The trajectory of an object depends on its initial conditions, such as position, velocity, and altitude. Initial Position : The location in space relative to the central body. Initial Velocity : The speed and direction at which the object is moving when it is first released or launched. Altitude : The height above the central body\u2019s surface, which influences the gravitational force and therefore the orbit. Impact on Trajectory If the initial velocity is less than the escape velocity, the object will follow an elliptical orbit. If the initial velocity is equal to the escape velocity, the object will follow a parabolic trajectory. If the initial velocity exceeds the escape velocity, the object will follow a hyperbolic trajectory. The escape velocity \\( v_{\\text{esc}} \\) is given by: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2 G m_1}{r}} \\] Where \\( r \\) is the initial distance from the center of the central body. 4. Analyzing the Relationship Between Trajectories and Orbital Insertion, Reentry, or Escape Scenarios Orbital Insertion : When a spacecraft enters orbit around a central body, its velocity must be carefully controlled to ensure it follows a stable elliptical orbit. This is typically done by adjusting the spacecraft\u2019s velocity via a maneuver known as a \"burn\". Reentry : For a spacecraft to reenter a planetary atmosphere, its trajectory must be adjusted so that it intersects the atmosphere at the correct angle and speed. A hyperbolic trajectory may result in a steep, high-speed reentry, which can be dangerous if not controlled. Escape : An object escapes the gravitational pull of the central body if it reaches or exceeds the escape velocity. This leads to a hyperbolic trajectory, and the object is no longer bound to the central body. The relationship between velocity and escape or reentry is crucial for mission planning, ensuring the correct orbital path for desired outcomes such as satellite deployment or interplanetary travel. Numerical Analysis In this section, we discuss the numerical methods used to solve the differential equations of motion for a payload under the influence of Earth\u2019s gravitational field. The goal is to simulate the payload\u2019s trajectory using a numerical approach and validate the results against known analytical expectations, such as a circular orbit. 1. Selecting a Numerical Method To solve the equations of motion numerically, we will use the Runge-Kutta method , specifically the 4th-order Runge-Kutta (RK4) method. This is a widely used method for solving ordinary differential equations (ODEs) because it offers a good balance between accuracy and computational efficiency. The general form of the Runge-Kutta method for a first-order differential equation \\(\\frac{dy}{dt} = f(t, y)\\) is: \\[ y_{n+1} = y_n + \\frac{h}{6} \\left( k_1 + 2k_2 + 2k_3 + k_4 \\right) \\] Where: - \\(h\\) is the step size, - \\(k_1 = f(t_n, y_n)\\) , - \\(k_2 = f(t_n + \\frac{h}{2}, y_n + \\frac{h}{2} k_1)\\) , - \\(k_3 = f(t_n + \\frac{h}{2}, y_n + \\frac{h}{2} k_2)\\) , - \\(k_4 = f(t_n + h, y_n + h k_3)\\) . Alternatively, the Euler method can be used as a simpler, though less accurate, numerical method: \\[ y_{n+1} = y_n + h f(t_n, y_n) \\] While Euler\u2019s method is easier to implement, it requires smaller step sizes for stability and is less accurate than Runge-Kutta, especially for more complex systems. 2. Setting Up Initial Conditions The initial conditions for the payload\u2019s trajectory must include the position vector, velocity vector, and altitude. We assume the payload is launched from a specific location near Earth\u2019s surface. Let the initial position vector \\(\\mathbf{r}_0\\) be: \\[ \\mathbf{r}_0 = \\begin{bmatrix} r_{x0} \\\\ r_{y0} \\\\ r_{z0} \\end{bmatrix} \\] Let the initial velocity vector \\(\\mathbf{v}_0\\) be: \\[ \\mathbf{v}_0 = \\begin{bmatrix} v_{x0} \\\\ v_{y0} \\\\ v_{z0} \\end{bmatrix} \\] The altitude \\(h_0\\) can be calculated as the distance from the center of Earth: \\[ h_0 = \\sqrt{r_{x0}^2 + r_{y0}^2 + r_{z0}^2} - R_E \\] Where \\(R_E\\) is the radius of Earth. The equations of motion under the influence of Earth's gravitational field are given by Newton\u2019s second law: \\[ \\mathbf{F} = m \\mathbf{a} = - \\frac{G M_E m}{r^2} \\hat{r} \\] Where: - \\(G\\) is the gravitational constant, - \\(M_E\\) is the mass of Earth, - \\(r\\) is the magnitude of the position vector \\(\\mathbf{r}\\) , - \\(\\hat{r}\\) is the unit vector in the direction of \\(\\mathbf{r}\\) . This force is used to update the velocity and position of the payload during each step of the numerical integration. 3. Computing the Payload's Path Using the initial conditions and the numerical method chosen (e.g., Runge-Kutta), we compute the trajectory of the payload over time. The numerical method will integrate the equations of motion iteratively. The velocity and position at each time step are updated as follows: \\[ \\mathbf{r}_{n+1} = \\mathbf{r}_n + h \\mathbf{v}_n \\] \\[ \\mathbf{v}_{n+1} = \\mathbf{v}_n + h \\frac{\\mathbf{F}_n}{m} \\] Where: - \\(\\mathbf{r}_n\\) and \\(\\mathbf{v}_n\\) are the position and velocity at the current time step, - \\(h\\) is the step size, - \\(\\mathbf{F}_n\\) is the gravitational force at the current position. We continue this process until we reach the desired time, at which point we will have a complete trajectory. 4. Validating Numerical Results After solving for the trajectory using the numerical method, we validate the results against known analytical expectations. For example, in the case of a circular orbit , the trajectory should maintain a constant radial distance from the center of Earth. In a circular orbit, the orbital velocity is constant and is given by: \\[ v_{\\text{circular}} = \\sqrt{\\frac{G M_E}{r}} \\] Where: - \\(r\\) is the orbital radius. We can compare the computed velocity at each point along the trajectory with this theoretical velocity for a circular orbit. For an elliptical orbit , we check if the computed trajectory satisfies Kepler\u2019s Laws, especially the law of equal areas, which implies that the object should sweep out equal areas during equal time intervals. In the case of more complex orbits or escape trajectories, we verify that the object\u2019s velocity exceeds the escape velocity at the correct point, leading to a trajectory that no longer returns to Earth. Example: Circular Orbit Validation For a payload in a circular orbit at an altitude of 300 km above the Earth's surface, we expect the following conditions: - The radius from the center of Earth is \\(r = R_E + 300 \\, \\text{km}\\) , - The orbital velocity should match the theoretical velocity: \\[ v_{\\text{orbital}} = \\sqrt{\\frac{G M_E}{R_E + 300}} \\] By comparing the computed velocity at each time step with this value, we can verify the accuracy of our numerical solution. Code and Plots import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_Earth = 5.972e24 # Mass of Earth (kg) R_Earth = 6.371e6 # Radius of Earth (m) # Earth's gravitational potential function def acceleration(t, y): x, y, vx, vy = y r = np.sqrt(x**2 + y**2) if r < R_Earth: # Prevent orbits from going through Earth return [0, 0, 0, 0] a_x = -G * M_Earth * x / r**3 a_y = -G * M_Earth * y / r**3 return [vx, vy, a_x, a_y] # Solve the equations of motion using solve_ivp def simulate_orbit(y0, t_span, dt): sol = solve_ivp(acceleration, t_span, y0, dense_output=True, rtol=1e-9, atol=1e-12) t = np.arange(t_span[0], t_span[1], dt) y = sol.sol(t) # Filter out points inside the Earth x, y_vals = y[0, :], y[1, :] r = np.sqrt(x**2 + y_vals**2) mask = r >= R_Earth x, y_vals = x[mask], y_vals[mask] return t[mask], np.array([x, y_vals]) # Plotting function def plot_orbits(trajectories, earth_radius=R_Earth): fig, ax = plt.subplots(figsize=(8, 8)) ax.set_aspect('equal') # Draw Earth circle = plt.Circle((0, 0), earth_radius, color='teal', alpha=0.4, label=\"Earth\") ax.add_artist(circle) # Plot trajectories colors = ['darkorange', 'forestgreen', 'crimson', 'navy', 'gold'] labels = [ \"Circular Orbit\", \"Elliptical Orbit\", \"Reentry Trajectory\", \"Escape Velocity\", \"Faster Than Circular\" ] for i, traj in enumerate(trajectories): if traj[1] is not None: x, y = traj[1][0, :], traj[1][1, :] ax.plot(x, y, label=labels[i], color=colors[i], linewidth=1.5) # Add labels and legend ax.set_xlabel(\"x Position [m]\") ax.set_ylabel(\"y Position [m]\") ax.legend(loc='upper right') ax.grid(True, linestyle='--', alpha=0.5) plt.title(\"Satellite Trajectories Around Earth\") plt.tight_layout() plt.show() # Define initial conditions for multiple trajectories trajectories = [] # Circular orbit y0_circular = [R_Earth + 1e6, 0, 0, np.sqrt(G * M_Earth / (R_Earth + 1e6))] trajectories.append(simulate_orbit(y0_circular, [0, 10000], 1)) # Elliptical orbit (slightly perturbed from circular) y0_elliptical = [R_Earth + 1e6, 0, 0, np.sqrt(G * M_Earth / (R_Earth + 1e6)) * 0.9] trajectories.append(simulate_orbit(y0_elliptical, [0, 12000], 1)) # Reentry trajectory (low velocity) y0_reentry = [R_Earth + 1e6, 0, 0, np.sqrt(G * M_Earth / (R_Earth + 1e6)) * 0.5] trajectories.append(simulate_orbit(y0_reentry, [0, 8000], 1)) # Escape trajectory (high velocity) y0_escape = [R_Earth + 1e6, 0, 0, np.sqrt(G * M_Earth / (R_Earth + 1e6)) * 1.5] trajectories.append(simulate_orbit(y0_escape, [0, 4000], 1)) # Faster than circular orbit y0_faster_circular = [R_Earth + 1e6, 0, 0, np.sqrt(G * M_Earth / (R_Earth + 1e6)) * 1.1] trajectories.append(simulate_orbit(y0_faster_circular, [0, 10000], 1)) # Plot all trajectories plot_orbits(trajectories) import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_Earth = 5.972e24 # Mass of Earth (kg) R_Earth = 6.371e6 # Radius of Earth (m) Earth_radius_plot = 1.0 # Earth radius in plot units (normalized) # Initial conditions initial_height = 800e3 # 800 km above Earth's surface (m) initial_position = np.array([R_Earth + initial_height, 0]) # Starting position (x, y) initial_velocity_min = 10e3 # Minimum initial velocity (m/s) initial_velocity_max = 20e3 # Maximum initial velocity (m/s) velocity_step = 1e3 # Step size for velocity (m/s) # Time span for simulation t_span = (0, 10000) # Simulation time in seconds # Function to compute acceleration due to gravity def acceleration(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) # Distance from Earth's center F = -G * M_Earth / r**3 # Gravitational force per unit mass ax = F * x ay = F * y return [vx, vy, ax, ay] # Solve ODE for each initial velocity trajectories = [] for v0 in np.arange(initial_velocity_min, initial_velocity_max + velocity_step, velocity_step): # Initial state: [x, y, vx, vy] initial_state = [*initial_position, 0, v0] # Zero horizontal velocity solution = solve_ivp(acceleration, t_span, initial_state, atol=1e-9, rtol=1e-9) trajectories.append(solution.y[:2]) # Store only x and y positions # Plot the results plt.figure(figsize=(8, 8)) plt.title(\"Trajectories in a Gravitational Field with Filled Earth\") plt.xlabel(\"x [Earth radii]\") plt.ylabel(\"y [Earth radii]\") # Plot Earth circle = plt.Circle((0, 0), Earth_radius_plot, color='blue', alpha=0.5, label=\"Earth\") plt.gca().add_patch(circle) # Plot trajectories colors = plt.cm.viridis(np.linspace(0, 1, len(trajectories))) for i, traj in enumerate(trajectories): x, y = traj plt.plot(x / R_Earth, y / R_Earth, color=colors[i], label=f\"v\u2080 = {initial_velocity_min + i * velocity_step / 1e3:.1f} km/s\") plt.legend() plt.axis('equal') plt.grid(True) plt.show() import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_Earth = 5.972e24 # Mass of Earth (kg) R_Earth = 6.371e6 # Radius of Earth (m) # Acceleration due to Earth's gravity def acceleration(t, y): x, y, vx, vy = y r = np.hypot(x, y) # Faster than sqrt(x**2 + y**2) if r < R_Earth: # Prevent going inside Earth return [0, 0, 0, 0] a = -G * M_Earth / r**3 return [vx, vy, a * x, a * y] # Simulate orbit given initial conditions def simulate_orbit(y0, t_span, dt): sol = solve_ivp(acceleration, t_span, y0, dense_output=True, rtol=1e-9, atol=1e-12) t = np.arange(*t_span, dt) x, y = sol.sol(t)[0], sol.sol(t)[1] r = np.hypot(x, y) mask = r >= R_Earth return x[mask], y[mask] # Plot multiple trajectories def plot_trajectories(initial_conditions_list, t_max=100000, num_points=20000): fig, ax = plt.subplots(figsize=(8, 8)) ax.set_aspect('equal') # Draw Earth earth_circle = plt.Circle((0, 0), R_Earth, color='teal', alpha=0.5, label=\"Earth\") ax.add_artist(earth_circle) colors = plt.cm.plasma(np.linspace(0, 1, len(initial_conditions_list))) dt = t_max / num_points for i, (x0, y0, vx0, vy0) in enumerate(initial_conditions_list): x_traj, y_traj = simulate_orbit([x0, y0, vx0, vy0], [0, t_max], dt) ax.plot(x_traj, y_traj, color=colors[i], linewidth=1.2, label=f\"v = {vy0:.0f} m/s\") # Axis settings ax.set_xlabel(\"x Position [m]\") ax.set_ylabel(\"y Position [m]\") ax.legend(loc='upper right', title=\"Initial Velocity\", fontsize='small') ax.grid(True, linestyle='--', alpha=0.5) plt.title(\"Satellite Trajectories Around Earth (Varying Initial Velocity)\") plt.tight_layout() plt.show() # Define initial conditions initial_conditions_list = [ (R_Earth + 1e6, 0, 0, 9000), (R_Earth + 1e6, 0, 0, 9100), (R_Earth + 1e6, 0, 0, 9200), (R_Earth + 1e6, 0, 0, 9300), (R_Earth + 1e6, 0, 0, 9400), (R_Earth + 1e6, 0, 0, 9500), (R_Earth + 1e6, 0, 0, 9600), (R_Earth + 1e6, 0, 0, 9700), (R_Earth + 1e6, 0, 0, 9800), (R_Earth + 1e6, 0, 0, 9900), (R_Earth + 1e6, 0, 0, 10000), ] # Run simulation and plot plot_trajectories(initial_conditions_list, t_max=100000, num_points=20000) Colab Colab","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-analysis","text":"In this section, we derive the equations of motion for orbital mechanics, focusing on Newton\u2019s Law of Gravitation, Kepler\u2019s Laws, and the impact of initial conditions on the trajectory of a spacecraft.","title":"Theoretical Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-deriving-equations-of-motion-using-newtons-law-of-gravitation","text":"Newton\u2019s Law of Gravitation gives the force between two masses, which is essential for understanding the motion of objects in space. The gravitational force \\( F \\) between two bodies is given by: \\[ F = G \\frac{m_1 m_2}{r^2} \\] Where: - \\( F \\) is the gravitational force, - \\( G \\) is the gravitational constant ( \\(6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) ), - \\( m_1 \\) and \\( m_2 \\) are the masses of the two bodies, - \\( r \\) is the distance between their centers. From Newton\u2019s second law of motion, the force is also equal to mass times acceleration, i.e., \\[ F = m a \\] Equating the two expressions for \\( F \\) , we get the equation of motion: \\[ m a = G \\frac{m_1 m_2}{r^2} \\] For a mass \\( m \\) orbiting a central body, we can simplify this to: \\[ a = G \\frac{m_1}{r^2} \\] This gives us the acceleration experienced by the orbiting body due to gravitational attraction.","title":"1. Deriving Equations of Motion Using Newton\u2019s Law of Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-applying-keplers-laws-to-classify-trajectories","text":"Kepler's Laws describe the motion of planets and other celestial bodies under the influence of gravity.","title":"2. Applying Kepler\u2019s Laws to Classify Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#keplers-first-law-the-law-of-ellipses","text":"The orbit of a planet (or other object) around a central body is an ellipse, with the central body at one focus. The equation for an ellipse in polar coordinates is: \\[ r(\\theta) = \\frac{a(1 - e^2)}{1 + e \\cos \\theta} \\] Where: - \\( r(\\theta) \\) is the radial distance as a function of the true anomaly \\( \\theta \\) , - \\( a \\) is the semi-major axis, - \\( e \\) is the eccentricity of the ellipse.","title":"Kepler\u2019s First Law: The Law of Ellipses"},{"location":"1%20Physics/2%20Gravity/Problem_3/#keplers-second-law-the-law-of-equal-areas","text":"A line segment joining a planet and the central body sweeps out equal areas during equal intervals of time. This implies that the object moves faster when closer to the central body and slower when farther away. This can be expressed as: \\[ \\frac{dA}{dt} = \\frac{1}{2} r^2 \\frac{d\\theta}{dt} = \\text{constant} \\]","title":"Kepler\u2019s Second Law: The Law of Equal Areas"},{"location":"1%20Physics/2%20Gravity/Problem_3/#keplers-third-law-the-law-of-periods","text":"The square of the orbital period \\( T \\) is proportional to the cube of the semi-major axis \\( a \\) of the orbit: \\[ T^2 = \\frac{4 \\pi^2 a^3}{G m_1} \\] Where: - \\( T \\) is the orbital period, - \\( a \\) is the semi-major axis of the orbit, - \\( m_1 \\) is the mass of the central body. Using Kepler\u2019s Third Law, we can classify possible trajectories into three types:","title":"Kepler\u2019s Third Law: The Law of Periods"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-elliptical-trajectory","text":"An object follows a closed elliptical path, typical for most planets, moons, and satellites. The trajectory is bound.","title":"1. Elliptical Trajectory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-parabolic-trajectory","text":"This is the case for an object that escapes a central body with exactly the escape velocity. The trajectory is unbound and follows a parabolic shape.","title":"2. Parabolic Trajectory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-hyperbolic-trajectory","text":"An object that exceeds the escape velocity follows a hyperbolic trajectory, which is also unbound.","title":"3. Hyperbolic Trajectory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-defining-initial-conditions-and-their-impact-on-trajectory-types","text":"The trajectory of an object depends on its initial conditions, such as position, velocity, and altitude. Initial Position : The location in space relative to the central body. Initial Velocity : The speed and direction at which the object is moving when it is first released or launched. Altitude : The height above the central body\u2019s surface, which influences the gravitational force and therefore the orbit.","title":"3. Defining Initial Conditions and Their Impact on Trajectory Types"},{"location":"1%20Physics/2%20Gravity/Problem_3/#impact-on-trajectory","text":"If the initial velocity is less than the escape velocity, the object will follow an elliptical orbit. If the initial velocity is equal to the escape velocity, the object will follow a parabolic trajectory. If the initial velocity exceeds the escape velocity, the object will follow a hyperbolic trajectory. The escape velocity \\( v_{\\text{esc}} \\) is given by: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2 G m_1}{r}} \\] Where \\( r \\) is the initial distance from the center of the central body.","title":"Impact on Trajectory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-analyzing-the-relationship-between-trajectories-and-orbital-insertion-reentry-or-escape-scenarios","text":"Orbital Insertion : When a spacecraft enters orbit around a central body, its velocity must be carefully controlled to ensure it follows a stable elliptical orbit. This is typically done by adjusting the spacecraft\u2019s velocity via a maneuver known as a \"burn\". Reentry : For a spacecraft to reenter a planetary atmosphere, its trajectory must be adjusted so that it intersects the atmosphere at the correct angle and speed. A hyperbolic trajectory may result in a steep, high-speed reentry, which can be dangerous if not controlled. Escape : An object escapes the gravitational pull of the central body if it reaches or exceeds the escape velocity. This leads to a hyperbolic trajectory, and the object is no longer bound to the central body. The relationship between velocity and escape or reentry is crucial for mission planning, ensuring the correct orbital path for desired outcomes such as satellite deployment or interplanetary travel.","title":"4. Analyzing the Relationship Between Trajectories and Orbital Insertion, Reentry, or Escape Scenarios"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-analysis","text":"In this section, we discuss the numerical methods used to solve the differential equations of motion for a payload under the influence of Earth\u2019s gravitational field. The goal is to simulate the payload\u2019s trajectory using a numerical approach and validate the results against known analytical expectations, such as a circular orbit.","title":"Numerical Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-selecting-a-numerical-method","text":"To solve the equations of motion numerically, we will use the Runge-Kutta method , specifically the 4th-order Runge-Kutta (RK4) method. This is a widely used method for solving ordinary differential equations (ODEs) because it offers a good balance between accuracy and computational efficiency. The general form of the Runge-Kutta method for a first-order differential equation \\(\\frac{dy}{dt} = f(t, y)\\) is: \\[ y_{n+1} = y_n + \\frac{h}{6} \\left( k_1 + 2k_2 + 2k_3 + k_4 \\right) \\] Where: - \\(h\\) is the step size, - \\(k_1 = f(t_n, y_n)\\) , - \\(k_2 = f(t_n + \\frac{h}{2}, y_n + \\frac{h}{2} k_1)\\) , - \\(k_3 = f(t_n + \\frac{h}{2}, y_n + \\frac{h}{2} k_2)\\) , - \\(k_4 = f(t_n + h, y_n + h k_3)\\) . Alternatively, the Euler method can be used as a simpler, though less accurate, numerical method: \\[ y_{n+1} = y_n + h f(t_n, y_n) \\] While Euler\u2019s method is easier to implement, it requires smaller step sizes for stability and is less accurate than Runge-Kutta, especially for more complex systems.","title":"1. Selecting a Numerical Method"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-setting-up-initial-conditions","text":"The initial conditions for the payload\u2019s trajectory must include the position vector, velocity vector, and altitude. We assume the payload is launched from a specific location near Earth\u2019s surface. Let the initial position vector \\(\\mathbf{r}_0\\) be: \\[ \\mathbf{r}_0 = \\begin{bmatrix} r_{x0} \\\\ r_{y0} \\\\ r_{z0} \\end{bmatrix} \\] Let the initial velocity vector \\(\\mathbf{v}_0\\) be: \\[ \\mathbf{v}_0 = \\begin{bmatrix} v_{x0} \\\\ v_{y0} \\\\ v_{z0} \\end{bmatrix} \\] The altitude \\(h_0\\) can be calculated as the distance from the center of Earth: \\[ h_0 = \\sqrt{r_{x0}^2 + r_{y0}^2 + r_{z0}^2} - R_E \\] Where \\(R_E\\) is the radius of Earth. The equations of motion under the influence of Earth's gravitational field are given by Newton\u2019s second law: \\[ \\mathbf{F} = m \\mathbf{a} = - \\frac{G M_E m}{r^2} \\hat{r} \\] Where: - \\(G\\) is the gravitational constant, - \\(M_E\\) is the mass of Earth, - \\(r\\) is the magnitude of the position vector \\(\\mathbf{r}\\) , - \\(\\hat{r}\\) is the unit vector in the direction of \\(\\mathbf{r}\\) . This force is used to update the velocity and position of the payload during each step of the numerical integration.","title":"2. Setting Up Initial Conditions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-computing-the-payloads-path","text":"Using the initial conditions and the numerical method chosen (e.g., Runge-Kutta), we compute the trajectory of the payload over time. The numerical method will integrate the equations of motion iteratively. The velocity and position at each time step are updated as follows: \\[ \\mathbf{r}_{n+1} = \\mathbf{r}_n + h \\mathbf{v}_n \\] \\[ \\mathbf{v}_{n+1} = \\mathbf{v}_n + h \\frac{\\mathbf{F}_n}{m} \\] Where: - \\(\\mathbf{r}_n\\) and \\(\\mathbf{v}_n\\) are the position and velocity at the current time step, - \\(h\\) is the step size, - \\(\\mathbf{F}_n\\) is the gravitational force at the current position. We continue this process until we reach the desired time, at which point we will have a complete trajectory.","title":"3. Computing the Payload's Path"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-validating-numerical-results","text":"After solving for the trajectory using the numerical method, we validate the results against known analytical expectations. For example, in the case of a circular orbit , the trajectory should maintain a constant radial distance from the center of Earth. In a circular orbit, the orbital velocity is constant and is given by: \\[ v_{\\text{circular}} = \\sqrt{\\frac{G M_E}{r}} \\] Where: - \\(r\\) is the orbital radius. We can compare the computed velocity at each point along the trajectory with this theoretical velocity for a circular orbit. For an elliptical orbit , we check if the computed trajectory satisfies Kepler\u2019s Laws, especially the law of equal areas, which implies that the object should sweep out equal areas during equal time intervals. In the case of more complex orbits or escape trajectories, we verify that the object\u2019s velocity exceeds the escape velocity at the correct point, leading to a trajectory that no longer returns to Earth.","title":"4. Validating Numerical Results"},{"location":"1%20Physics/2%20Gravity/Problem_3/#example-circular-orbit-validation","text":"For a payload in a circular orbit at an altitude of 300 km above the Earth's surface, we expect the following conditions: - The radius from the center of Earth is \\(r = R_E + 300 \\, \\text{km}\\) , - The orbital velocity should match the theoretical velocity: \\[ v_{\\text{orbital}} = \\sqrt{\\frac{G M_E}{R_E + 300}} \\]","title":"Example: Circular Orbit Validation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#by-comparing-the-computed-velocity-at-each-time-step-with-this-value-we-can-verify-the-accuracy-of-our-numerical-solution","text":"","title":"By comparing the computed velocity at each time step with this value, we can verify the accuracy of our numerical solution."},{"location":"1%20Physics/2%20Gravity/Problem_3/#code-and-plots","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_Earth = 5.972e24 # Mass of Earth (kg) R_Earth = 6.371e6 # Radius of Earth (m) # Earth's gravitational potential function def acceleration(t, y): x, y, vx, vy = y r = np.sqrt(x**2 + y**2) if r < R_Earth: # Prevent orbits from going through Earth return [0, 0, 0, 0] a_x = -G * M_Earth * x / r**3 a_y = -G * M_Earth * y / r**3 return [vx, vy, a_x, a_y] # Solve the equations of motion using solve_ivp def simulate_orbit(y0, t_span, dt): sol = solve_ivp(acceleration, t_span, y0, dense_output=True, rtol=1e-9, atol=1e-12) t = np.arange(t_span[0], t_span[1], dt) y = sol.sol(t) # Filter out points inside the Earth x, y_vals = y[0, :], y[1, :] r = np.sqrt(x**2 + y_vals**2) mask = r >= R_Earth x, y_vals = x[mask], y_vals[mask] return t[mask], np.array([x, y_vals]) # Plotting function def plot_orbits(trajectories, earth_radius=R_Earth): fig, ax = plt.subplots(figsize=(8, 8)) ax.set_aspect('equal') # Draw Earth circle = plt.Circle((0, 0), earth_radius, color='teal', alpha=0.4, label=\"Earth\") ax.add_artist(circle) # Plot trajectories colors = ['darkorange', 'forestgreen', 'crimson', 'navy', 'gold'] labels = [ \"Circular Orbit\", \"Elliptical Orbit\", \"Reentry Trajectory\", \"Escape Velocity\", \"Faster Than Circular\" ] for i, traj in enumerate(trajectories): if traj[1] is not None: x, y = traj[1][0, :], traj[1][1, :] ax.plot(x, y, label=labels[i], color=colors[i], linewidth=1.5) # Add labels and legend ax.set_xlabel(\"x Position [m]\") ax.set_ylabel(\"y Position [m]\") ax.legend(loc='upper right') ax.grid(True, linestyle='--', alpha=0.5) plt.title(\"Satellite Trajectories Around Earth\") plt.tight_layout() plt.show() # Define initial conditions for multiple trajectories trajectories = [] # Circular orbit y0_circular = [R_Earth + 1e6, 0, 0, np.sqrt(G * M_Earth / (R_Earth + 1e6))] trajectories.append(simulate_orbit(y0_circular, [0, 10000], 1)) # Elliptical orbit (slightly perturbed from circular) y0_elliptical = [R_Earth + 1e6, 0, 0, np.sqrt(G * M_Earth / (R_Earth + 1e6)) * 0.9] trajectories.append(simulate_orbit(y0_elliptical, [0, 12000], 1)) # Reentry trajectory (low velocity) y0_reentry = [R_Earth + 1e6, 0, 0, np.sqrt(G * M_Earth / (R_Earth + 1e6)) * 0.5] trajectories.append(simulate_orbit(y0_reentry, [0, 8000], 1)) # Escape trajectory (high velocity) y0_escape = [R_Earth + 1e6, 0, 0, np.sqrt(G * M_Earth / (R_Earth + 1e6)) * 1.5] trajectories.append(simulate_orbit(y0_escape, [0, 4000], 1)) # Faster than circular orbit y0_faster_circular = [R_Earth + 1e6, 0, 0, np.sqrt(G * M_Earth / (R_Earth + 1e6)) * 1.1] trajectories.append(simulate_orbit(y0_faster_circular, [0, 10000], 1)) # Plot all trajectories plot_orbits(trajectories) import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_Earth = 5.972e24 # Mass of Earth (kg) R_Earth = 6.371e6 # Radius of Earth (m) Earth_radius_plot = 1.0 # Earth radius in plot units (normalized) # Initial conditions initial_height = 800e3 # 800 km above Earth's surface (m) initial_position = np.array([R_Earth + initial_height, 0]) # Starting position (x, y) initial_velocity_min = 10e3 # Minimum initial velocity (m/s) initial_velocity_max = 20e3 # Maximum initial velocity (m/s) velocity_step = 1e3 # Step size for velocity (m/s) # Time span for simulation t_span = (0, 10000) # Simulation time in seconds # Function to compute acceleration due to gravity def acceleration(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) # Distance from Earth's center F = -G * M_Earth / r**3 # Gravitational force per unit mass ax = F * x ay = F * y return [vx, vy, ax, ay] # Solve ODE for each initial velocity trajectories = [] for v0 in np.arange(initial_velocity_min, initial_velocity_max + velocity_step, velocity_step): # Initial state: [x, y, vx, vy] initial_state = [*initial_position, 0, v0] # Zero horizontal velocity solution = solve_ivp(acceleration, t_span, initial_state, atol=1e-9, rtol=1e-9) trajectories.append(solution.y[:2]) # Store only x and y positions # Plot the results plt.figure(figsize=(8, 8)) plt.title(\"Trajectories in a Gravitational Field with Filled Earth\") plt.xlabel(\"x [Earth radii]\") plt.ylabel(\"y [Earth radii]\") # Plot Earth circle = plt.Circle((0, 0), Earth_radius_plot, color='blue', alpha=0.5, label=\"Earth\") plt.gca().add_patch(circle) # Plot trajectories colors = plt.cm.viridis(np.linspace(0, 1, len(trajectories))) for i, traj in enumerate(trajectories): x, y = traj plt.plot(x / R_Earth, y / R_Earth, color=colors[i], label=f\"v\u2080 = {initial_velocity_min + i * velocity_step / 1e3:.1f} km/s\") plt.legend() plt.axis('equal') plt.grid(True) plt.show() import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_Earth = 5.972e24 # Mass of Earth (kg) R_Earth = 6.371e6 # Radius of Earth (m) # Acceleration due to Earth's gravity def acceleration(t, y): x, y, vx, vy = y r = np.hypot(x, y) # Faster than sqrt(x**2 + y**2) if r < R_Earth: # Prevent going inside Earth return [0, 0, 0, 0] a = -G * M_Earth / r**3 return [vx, vy, a * x, a * y] # Simulate orbit given initial conditions def simulate_orbit(y0, t_span, dt): sol = solve_ivp(acceleration, t_span, y0, dense_output=True, rtol=1e-9, atol=1e-12) t = np.arange(*t_span, dt) x, y = sol.sol(t)[0], sol.sol(t)[1] r = np.hypot(x, y) mask = r >= R_Earth return x[mask], y[mask] # Plot multiple trajectories def plot_trajectories(initial_conditions_list, t_max=100000, num_points=20000): fig, ax = plt.subplots(figsize=(8, 8)) ax.set_aspect('equal') # Draw Earth earth_circle = plt.Circle((0, 0), R_Earth, color='teal', alpha=0.5, label=\"Earth\") ax.add_artist(earth_circle) colors = plt.cm.plasma(np.linspace(0, 1, len(initial_conditions_list))) dt = t_max / num_points for i, (x0, y0, vx0, vy0) in enumerate(initial_conditions_list): x_traj, y_traj = simulate_orbit([x0, y0, vx0, vy0], [0, t_max], dt) ax.plot(x_traj, y_traj, color=colors[i], linewidth=1.2, label=f\"v = {vy0:.0f} m/s\") # Axis settings ax.set_xlabel(\"x Position [m]\") ax.set_ylabel(\"y Position [m]\") ax.legend(loc='upper right', title=\"Initial Velocity\", fontsize='small') ax.grid(True, linestyle='--', alpha=0.5) plt.title(\"Satellite Trajectories Around Earth (Varying Initial Velocity)\") plt.tight_layout() plt.show() # Define initial conditions initial_conditions_list = [ (R_Earth + 1e6, 0, 0, 9000), (R_Earth + 1e6, 0, 0, 9100), (R_Earth + 1e6, 0, 0, 9200), (R_Earth + 1e6, 0, 0, 9300), (R_Earth + 1e6, 0, 0, 9400), (R_Earth + 1e6, 0, 0, 9500), (R_Earth + 1e6, 0, 0, 9600), (R_Earth + 1e6, 0, 0, 9700), (R_Earth + 1e6, 0, 0, 9800), (R_Earth + 1e6, 0, 0, 9900), (R_Earth + 1e6, 0, 0, 10000), ] # Run simulation and plot plot_trajectories(initial_conditions_list, t_max=100000, num_points=20000)","title":"Code and Plots"},{"location":"1%20Physics/2%20Gravity/Problem_3/#colab","text":"Colab","title":"Colab"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Problem Setup: Coherent Wave Sources on a Regular Polygon 1. Geometric Configuration We begin by selecting a regular polygon with \\(N\\) vertices. Each vertex is assigned a coherent point wave source. Common choices include: Equilateral triangle ( \\(N = 3\\) ) Square ( \\(N = 4\\) ) Regular pentagon ( \\(N = 5\\) ) Assume the polygon is inscribed in a circle of radius \\(R\\) , centered at the origin \\((0, 0)\\) . The position \\(\\vec{r}_n\\) of the \\(n\\) -th source is given in Cartesian coordinates by: \\[ \\vec{r}_n = R \\begin{bmatrix} \\cos\\left( \\theta_n \\right) \\\\ \\sin\\left( \\theta_n \\right) \\end{bmatrix}, \\quad \\theta_n = \\frac{2\\pi n}{N}, \\quad n = 0, 1, \\dots, N-1 \\] Each point source emits a spherical (or circular, in 2D) wave centered at \\(\\vec{r}_n\\) . 2. Wave Parameters All sources emit waves that are coherent , meaning they share identical physical properties: Amplitude : \\(A\\) Wavelength : \\(\\lambda\\) Frequency : \\(f\\) Initial Phase : \\(\\phi_0\\) (same for all) The wavenumber \\(k\\) and angular frequency \\(\\omega\\) are defined by: \\[ k = \\frac{2\\pi}{\\lambda}, \\quad \\omega = 2\\pi f \\] Each source emits a wave of the form: \\[ \\psi_n(\\vec{r}, t) = A \\cdot \\frac{1}{|\\vec{r} - \\vec{r}_n|} \\cdot \\cos\\left( k |\\vec{r} - \\vec{r}_n| - \\omega t + \\phi_0 \\right) \\] In 2D, the \\(1/|\\vec{r} - \\vec{r}_n|\\) decay can be replaced by a logarithmic or Bessel-type function depending on boundary conditions and dimensionality, but for simplicity, we retain the inverse-distance decay. 3. Superposition Principle The total wave field at a point \\(\\vec{r}\\) is the superposition of the fields from all \\(N\\) sources: \\[ \\Psi(\\vec{r}, t) = \\sum_{n=0}^{N-1} \\psi_n(\\vec{r}, t) \\] Since all sources are coherent, interference patterns will emerge due to the phase differences arising from different path lengths. 4. Simplified Case: Far-Field Approximation In the far-field regime ( \\(|\\vec{r}| \\gg R\\) ), the distance approximation becomes: \\[ |\\vec{r} - \\vec{r}_n| \\approx r - \\hat{r} \\cdot \\vec{r}_n \\] where \\(\\hat{r} = \\vec{r} / |\\vec{r}|\\) is the unit vector in the observation direction. The wave from each source becomes: \\[ \\psi_n(\\vec{r}, t) \\approx \\frac{A}{r} \\cos\\left( k r - k \\hat{r} \\cdot \\vec{r}_n - \\omega t + \\phi_0 \\right) \\] And the total field becomes: \\[ \\Psi(\\vec{r}, t) \\approx \\frac{A}{r} \\sum_{n=0}^{N-1} \\cos\\left( k r - k \\hat{r} \\cdot \\vec{r}_n - \\omega t + \\phi_0 \\right) \\] This form is useful for analyzing angular interference patterns and diffraction lobes. 5. Summary of Parameters Symbol Description \\(N\\) Number of wave sources \\(R\\) Radius of circumscribed circle \\(A\\) Amplitude of each wave \\(\\lambda\\) Wavelength \\(f\\) Frequency \\(\\phi_0\\) Initial phase (common) \\(k\\) Wavenumber, \\(k = \\frac{2\\pi}{\\lambda}\\) \\(\\omega\\) Angular frequency, \\(\\omega = 2\\pi f\\) Note: These notes assume ideal, isotropic, and lossless wave propagation. Further analysis may consider boundary effects, damping, or nonlinearity. Mathematical Formulation We now formally describe the wave behavior generated by multiple coherent point sources located at the vertices of a regular polygon. 1. Single Point Source Wave Equation The surface displacement \\(\\eta(\\vec{r}, t)\\) at a point \\(\\vec{r} = (x, y)\\) on the water surface due to a single point source is described by: \\[ \\eta(\\vec{r}, t) = A \\cos(k r - \\omega t + \\phi) \\] where: \\(A\\) is the wave amplitude \\(k\\) is the wavenumber: \\(k = \\frac{2\\pi}{\\lambda}\\) \\(\\omega\\) is the angular frequency: \\(\\omega = 2\\pi f\\) \\(\\phi\\) is the initial phase \\(r = |\\vec{r} - \\vec{r}_i|\\) is the distance between the observation point and the source 2. Wave Equation for Multiple Sources Let there be \\(N\\) sources located at positions \\(\\vec{r}_i = (x_i, y_i)\\) for \\(i = 0, 1, ..., N-1\\) . The distance from the \\(i\\) -th source to a point \\((x, y)\\) on the water surface is: \\[ r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\] The surface displacement due to the \\(i\\) -th source is then: \\[ \\eta_i(x, y, t) = A \\cos(k r_i - \\omega t + \\phi) \\] Since all sources are coherent and have the same amplitude \\(A\\) , wavelength \\(\\lambda\\) , frequency \\(f\\) , and initial phase \\(\\phi\\) , the only variable is the distance \\(r_i\\) . 3. Total Surface Displacement by Superposition Using the linear superposition principle, the total displacement at point \\((x, y)\\) and time \\(t\\) due to all \\(N\\) sources is: \\[ \\eta_{\\text{total}}(x, y, t) = \\sum_{i=0}^{N-1} \\eta_i(x, y, t) \\] Substituting the individual waveforms: \\[ \\eta_{\\text{total}}(x, y, t) = \\sum_{i=0}^{N-1} A \\cos\\left(k \\sqrt{(x - x_i)^2 + (y - y_i)^2} - \\omega t + \\phi \\right) \\] This expression gives the instantaneous surface profile of the water at any point \\((x, y)\\) and time \\(t\\) due to multiple coherent sources. 4. Key Definitions Recap Symbol Description \\(A\\) Amplitude of each wave \\(\\lambda\\) Wavelength \\(f\\) Frequency \\(k\\) Wavenumber, \\(k = \\dfrac{2\\pi}{\\lambda}\\) \\(\\omega\\) Angular frequency, \\(\\omega = 2\\pi f\\) \\(\\phi\\) Initial phase (identical for all) \\((x_i, y_i)\\) Coordinates of source \\(i\\) \\((x, y)\\) Observation point on the surface \\(r_i\\) Distance from source \\(i\\) to \\((x, y)\\) Note: This formulation assumes the medium is homogeneous, isotropic, and supports linear wave propagation. Nonlinear or dissipative effects are neglected in this model. 3. Interference Analysis Interference arises when multiple coherent wave sources overlap spatially and temporally. The resulting surface displacement \\(\\eta_{\\text{total}}(x, y, t)\\) is the sum of individual contributions from each source, leading to patterns of constructive and destructive interference. 3.1 Constructive Interference Constructive interference occurs at points where the phase difference between waves from different sources is an integer multiple of \\(2\\pi\\) : \\[ k(r_i - r_j) = 2\\pi m, \\quad m \\in \\mathbb{Z} \\] This simplifies to: \\[ r_i - r_j = m \\lambda \\] At such points, the cosine terms align in phase, reinforcing each other. The amplitude of the total wave displacement is maximized. Conditions: Equal distances from the observation point to multiple sources (or integer-multiple differences) \\(\\eta_{\\text{total}}(x, y, t)\\) reaches local maxima 3.2 Destructive Interference Destructive interference occurs when the phase difference between sources equals an odd multiple of \\(\\pi\\) : \\[ k(r_i - r_j) = (2m + 1)\\pi, \\quad m \\in \\mathbb{Z} \\] This implies: \\[ r_i - r_j = \\left(m + \\frac{1}{2}\\right)\\lambda \\] Waves at these points arrive out of phase and cancel, resulting in minimal or zero net displacement. Conditions: Half-wavelength path differences Phase opposition leads to amplitude nullification 3.3 Spatial and Temporal Dependence The total wave field depends on both position \\((x, y)\\) and time \\(t\\) : \\[ \\eta_{\\text{total}}(x, y, t) = \\sum_{i=0}^{N-1} A \\cos\\left(k r_i(x, y) - \\omega t + \\phi\\right) \\] At any fixed \\(t\\) , the spatial pattern of interference can be analyzed as a standing wave pattern formed by overlapping traveling waves. Over time, these patterns oscillate sinusoidally , but their constructive/destructive regions remain fixed in space unless the wave properties or source positions change. 3.4 Effect of Polygon Geometry The geometry of the regular polygon significantly influences the interference pattern: Symmetry : Regular polygons induce radial and rotational symmetry in the interference field. Number of Sides ( \\(N\\) ) : More sources increase complexity and introduce higher angular harmonics in the interference pattern. Vertex Spacing : As vertices become more densely packed (e.g., larger \\(N\\) ), interference fringes become finer and more numerous. For instance: A triangle ( \\(N = 3\\) ) creates broad, triangularly symmetric lobes. A square ( \\(N = 4\\) ) induces fourfold symmetry and checkerboard-like regions of interference. A pentagon ( \\(N = 5\\) ) yields complex, star-like interference fields due to irrational angle multiples. These effects stem from the phase differences governed by: \\[ r_i(x, y) = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\] which depend on the geometric layout of source positions \\(\\{(x_i, y_i)\\}\\) . Conclusion: Interference is governed by the superposition of coherent waves with fixed phase relationships. Geometry plays a central role, and the resulting spatial interference pattern reflects both the physical arrangement and the wave parameters. Code and Plots # Install required library !pip install -q imageio # Imports import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation, PillowWriter from IPython.display import Image, display from google.colab import files # Constants c = 1.0 # Wave speed f = 1.0 # Frequency \u03bb = c / f # Wavelength k = 2 * np.pi / \u03bb # Wave number \u03c9 = 2 * np.pi * f # Angular frequency # Grid x = np.linspace(-10, 10, 300) y = np.linspace(-10, 10, 300) X, Y = np.meshgrid(x, y) # Function for a single wave source def wave_from_source(X, Y, x0, y0, t): r = np.sqrt((X - x0)**2 + (Y - y0)**2) return np.sin(k * r - \u03c9 * t) / (r + 1e-6) # Combine all waves from sources def total_wave(X, Y, sources, t): total = np.zeros_like(X) for x0, y0 in sources: total += wave_from_source(X, Y, x0, y0, t) return total # Create regular polygon of sources def generate_polygon_sources(n, radius=3): if n == 1: return [(0, 0)] angles = np.linspace(0, 2 * np.pi, n, endpoint=False) return [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Create animation and save GIF def create_wave_gif(sources, filename): fig, ax = plt.subplots(figsize=(6, 5)) Z = total_wave(X, Y, sources, 0) im = ax.imshow(Z, extent=[x.min(), x.max(), y.min(), y.max()], origin='lower', cmap='viridis', animated=True) ax.set_title(f'Wave Interference from {len(sources)} Source(s)') ax.set_xlabel('X') ax.set_ylabel('Y') plt.colorbar(im, ax=ax, label='Amplitude') def update(frame): t = frame / 10.0 Z = total_wave(X, Y, sources, t) im.set_array(Z) return [im] ani = FuncAnimation(fig, update, frames=50, interval=50, blit=True) ani.save(filename, writer=PillowWriter(fps=10)) plt.close() # Generate, display, and download animations for n in [1, 2, 3, 4, 5, 15]: # \u2190 You can change this to range(1, 31) for full set sources = generate_polygon_sources(n) gif_filename = f\"wave_{n}_sources.gif\" create_wave_gif(sources, gif_filename) display(Image(filename=gif_filename)) files.download(gif_filename) Colab Colab","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-setup-coherent-wave-sources-on-a-regular-polygon","text":"","title":"Problem Setup: Coherent Wave Sources on a Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-geometric-configuration","text":"We begin by selecting a regular polygon with \\(N\\) vertices. Each vertex is assigned a coherent point wave source. Common choices include: Equilateral triangle ( \\(N = 3\\) ) Square ( \\(N = 4\\) ) Regular pentagon ( \\(N = 5\\) ) Assume the polygon is inscribed in a circle of radius \\(R\\) , centered at the origin \\((0, 0)\\) . The position \\(\\vec{r}_n\\) of the \\(n\\) -th source is given in Cartesian coordinates by: \\[ \\vec{r}_n = R \\begin{bmatrix} \\cos\\left( \\theta_n \\right) \\\\ \\sin\\left( \\theta_n \\right) \\end{bmatrix}, \\quad \\theta_n = \\frac{2\\pi n}{N}, \\quad n = 0, 1, \\dots, N-1 \\] Each point source emits a spherical (or circular, in 2D) wave centered at \\(\\vec{r}_n\\) .","title":"1. Geometric Configuration"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-wave-parameters","text":"All sources emit waves that are coherent , meaning they share identical physical properties: Amplitude : \\(A\\) Wavelength : \\(\\lambda\\) Frequency : \\(f\\) Initial Phase : \\(\\phi_0\\) (same for all) The wavenumber \\(k\\) and angular frequency \\(\\omega\\) are defined by: \\[ k = \\frac{2\\pi}{\\lambda}, \\quad \\omega = 2\\pi f \\] Each source emits a wave of the form: \\[ \\psi_n(\\vec{r}, t) = A \\cdot \\frac{1}{|\\vec{r} - \\vec{r}_n|} \\cdot \\cos\\left( k |\\vec{r} - \\vec{r}_n| - \\omega t + \\phi_0 \\right) \\] In 2D, the \\(1/|\\vec{r} - \\vec{r}_n|\\) decay can be replaced by a logarithmic or Bessel-type function depending on boundary conditions and dimensionality, but for simplicity, we retain the inverse-distance decay.","title":"2. Wave Parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-superposition-principle","text":"The total wave field at a point \\(\\vec{r}\\) is the superposition of the fields from all \\(N\\) sources: \\[ \\Psi(\\vec{r}, t) = \\sum_{n=0}^{N-1} \\psi_n(\\vec{r}, t) \\] Since all sources are coherent, interference patterns will emerge due to the phase differences arising from different path lengths.","title":"3. Superposition Principle"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-simplified-case-far-field-approximation","text":"In the far-field regime ( \\(|\\vec{r}| \\gg R\\) ), the distance approximation becomes: \\[ |\\vec{r} - \\vec{r}_n| \\approx r - \\hat{r} \\cdot \\vec{r}_n \\] where \\(\\hat{r} = \\vec{r} / |\\vec{r}|\\) is the unit vector in the observation direction. The wave from each source becomes: \\[ \\psi_n(\\vec{r}, t) \\approx \\frac{A}{r} \\cos\\left( k r - k \\hat{r} \\cdot \\vec{r}_n - \\omega t + \\phi_0 \\right) \\] And the total field becomes: \\[ \\Psi(\\vec{r}, t) \\approx \\frac{A}{r} \\sum_{n=0}^{N-1} \\cos\\left( k r - k \\hat{r} \\cdot \\vec{r}_n - \\omega t + \\phi_0 \\right) \\] This form is useful for analyzing angular interference patterns and diffraction lobes.","title":"4. Simplified Case: Far-Field Approximation"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-summary-of-parameters","text":"Symbol Description \\(N\\) Number of wave sources \\(R\\) Radius of circumscribed circle \\(A\\) Amplitude of each wave \\(\\lambda\\) Wavelength \\(f\\) Frequency \\(\\phi_0\\) Initial phase (common) \\(k\\) Wavenumber, \\(k = \\frac{2\\pi}{\\lambda}\\) \\(\\omega\\) Angular frequency, \\(\\omega = 2\\pi f\\) Note: These notes assume ideal, isotropic, and lossless wave propagation. Further analysis may consider boundary effects, damping, or nonlinearity.","title":"5. Summary of Parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#mathematical-formulation","text":"We now formally describe the wave behavior generated by multiple coherent point sources located at the vertices of a regular polygon.","title":"Mathematical Formulation"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-single-point-source-wave-equation","text":"The surface displacement \\(\\eta(\\vec{r}, t)\\) at a point \\(\\vec{r} = (x, y)\\) on the water surface due to a single point source is described by: \\[ \\eta(\\vec{r}, t) = A \\cos(k r - \\omega t + \\phi) \\] where: \\(A\\) is the wave amplitude \\(k\\) is the wavenumber: \\(k = \\frac{2\\pi}{\\lambda}\\) \\(\\omega\\) is the angular frequency: \\(\\omega = 2\\pi f\\) \\(\\phi\\) is the initial phase \\(r = |\\vec{r} - \\vec{r}_i|\\) is the distance between the observation point and the source","title":"1. Single Point Source Wave Equation"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-wave-equation-for-multiple-sources","text":"Let there be \\(N\\) sources located at positions \\(\\vec{r}_i = (x_i, y_i)\\) for \\(i = 0, 1, ..., N-1\\) . The distance from the \\(i\\) -th source to a point \\((x, y)\\) on the water surface is: \\[ r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\] The surface displacement due to the \\(i\\) -th source is then: \\[ \\eta_i(x, y, t) = A \\cos(k r_i - \\omega t + \\phi) \\] Since all sources are coherent and have the same amplitude \\(A\\) , wavelength \\(\\lambda\\) , frequency \\(f\\) , and initial phase \\(\\phi\\) , the only variable is the distance \\(r_i\\) .","title":"2. Wave Equation for Multiple Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-total-surface-displacement-by-superposition","text":"Using the linear superposition principle, the total displacement at point \\((x, y)\\) and time \\(t\\) due to all \\(N\\) sources is: \\[ \\eta_{\\text{total}}(x, y, t) = \\sum_{i=0}^{N-1} \\eta_i(x, y, t) \\] Substituting the individual waveforms: \\[ \\eta_{\\text{total}}(x, y, t) = \\sum_{i=0}^{N-1} A \\cos\\left(k \\sqrt{(x - x_i)^2 + (y - y_i)^2} - \\omega t + \\phi \\right) \\] This expression gives the instantaneous surface profile of the water at any point \\((x, y)\\) and time \\(t\\) due to multiple coherent sources.","title":"3. Total Surface Displacement by Superposition"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-key-definitions-recap","text":"Symbol Description \\(A\\) Amplitude of each wave \\(\\lambda\\) Wavelength \\(f\\) Frequency \\(k\\) Wavenumber, \\(k = \\dfrac{2\\pi}{\\lambda}\\) \\(\\omega\\) Angular frequency, \\(\\omega = 2\\pi f\\) \\(\\phi\\) Initial phase (identical for all) \\((x_i, y_i)\\) Coordinates of source \\(i\\) \\((x, y)\\) Observation point on the surface \\(r_i\\) Distance from source \\(i\\) to \\((x, y)\\) Note: This formulation assumes the medium is homogeneous, isotropic, and supports linear wave propagation. Nonlinear or dissipative effects are neglected in this model.","title":"4. Key Definitions Recap"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-interference-analysis","text":"Interference arises when multiple coherent wave sources overlap spatially and temporally. The resulting surface displacement \\(\\eta_{\\text{total}}(x, y, t)\\) is the sum of individual contributions from each source, leading to patterns of constructive and destructive interference.","title":"3. Interference Analysis"},{"location":"1%20Physics/3%20Waves/Problem_1/#31-constructive-interference","text":"Constructive interference occurs at points where the phase difference between waves from different sources is an integer multiple of \\(2\\pi\\) : \\[ k(r_i - r_j) = 2\\pi m, \\quad m \\in \\mathbb{Z} \\] This simplifies to: \\[ r_i - r_j = m \\lambda \\] At such points, the cosine terms align in phase, reinforcing each other. The amplitude of the total wave displacement is maximized.","title":"3.1 Constructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#conditions","text":"Equal distances from the observation point to multiple sources (or integer-multiple differences) \\(\\eta_{\\text{total}}(x, y, t)\\) reaches local maxima","title":"Conditions:"},{"location":"1%20Physics/3%20Waves/Problem_1/#32-destructive-interference","text":"Destructive interference occurs when the phase difference between sources equals an odd multiple of \\(\\pi\\) : \\[ k(r_i - r_j) = (2m + 1)\\pi, \\quad m \\in \\mathbb{Z} \\] This implies: \\[ r_i - r_j = \\left(m + \\frac{1}{2}\\right)\\lambda \\] Waves at these points arrive out of phase and cancel, resulting in minimal or zero net displacement.","title":"3.2 Destructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#conditions_1","text":"Half-wavelength path differences Phase opposition leads to amplitude nullification","title":"Conditions:"},{"location":"1%20Physics/3%20Waves/Problem_1/#33-spatial-and-temporal-dependence","text":"The total wave field depends on both position \\((x, y)\\) and time \\(t\\) : \\[ \\eta_{\\text{total}}(x, y, t) = \\sum_{i=0}^{N-1} A \\cos\\left(k r_i(x, y) - \\omega t + \\phi\\right) \\] At any fixed \\(t\\) , the spatial pattern of interference can be analyzed as a standing wave pattern formed by overlapping traveling waves. Over time, these patterns oscillate sinusoidally , but their constructive/destructive regions remain fixed in space unless the wave properties or source positions change.","title":"3.3 Spatial and Temporal Dependence"},{"location":"1%20Physics/3%20Waves/Problem_1/#34-effect-of-polygon-geometry","text":"The geometry of the regular polygon significantly influences the interference pattern: Symmetry : Regular polygons induce radial and rotational symmetry in the interference field. Number of Sides ( \\(N\\) ) : More sources increase complexity and introduce higher angular harmonics in the interference pattern. Vertex Spacing : As vertices become more densely packed (e.g., larger \\(N\\) ), interference fringes become finer and more numerous. For instance: A triangle ( \\(N = 3\\) ) creates broad, triangularly symmetric lobes. A square ( \\(N = 4\\) ) induces fourfold symmetry and checkerboard-like regions of interference. A pentagon ( \\(N = 5\\) ) yields complex, star-like interference fields due to irrational angle multiples. These effects stem from the phase differences governed by: \\[ r_i(x, y) = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\] which depend on the geometric layout of source positions \\(\\{(x_i, y_i)\\}\\) . Conclusion: Interference is governed by the superposition of coherent waves with fixed phase relationships. Geometry plays a central role, and the resulting spatial interference pattern reflects both the physical arrangement and the wave parameters.","title":"3.4 Effect of Polygon Geometry"},{"location":"1%20Physics/3%20Waves/Problem_1/#code-and-plots","text":"# Install required library !pip install -q imageio # Imports import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation, PillowWriter from IPython.display import Image, display from google.colab import files # Constants c = 1.0 # Wave speed f = 1.0 # Frequency \u03bb = c / f # Wavelength k = 2 * np.pi / \u03bb # Wave number \u03c9 = 2 * np.pi * f # Angular frequency # Grid x = np.linspace(-10, 10, 300) y = np.linspace(-10, 10, 300) X, Y = np.meshgrid(x, y) # Function for a single wave source def wave_from_source(X, Y, x0, y0, t): r = np.sqrt((X - x0)**2 + (Y - y0)**2) return np.sin(k * r - \u03c9 * t) / (r + 1e-6) # Combine all waves from sources def total_wave(X, Y, sources, t): total = np.zeros_like(X) for x0, y0 in sources: total += wave_from_source(X, Y, x0, y0, t) return total # Create regular polygon of sources def generate_polygon_sources(n, radius=3): if n == 1: return [(0, 0)] angles = np.linspace(0, 2 * np.pi, n, endpoint=False) return [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Create animation and save GIF def create_wave_gif(sources, filename): fig, ax = plt.subplots(figsize=(6, 5)) Z = total_wave(X, Y, sources, 0) im = ax.imshow(Z, extent=[x.min(), x.max(), y.min(), y.max()], origin='lower', cmap='viridis', animated=True) ax.set_title(f'Wave Interference from {len(sources)} Source(s)') ax.set_xlabel('X') ax.set_ylabel('Y') plt.colorbar(im, ax=ax, label='Amplitude') def update(frame): t = frame / 10.0 Z = total_wave(X, Y, sources, t) im.set_array(Z) return [im] ani = FuncAnimation(fig, update, frames=50, interval=50, blit=True) ani.save(filename, writer=PillowWriter(fps=10)) plt.close() # Generate, display, and download animations for n in [1, 2, 3, 4, 5, 15]: # \u2190 You can change this to range(1, 31) for full set sources = generate_polygon_sources(n) gif_filename = f\"wave_{n}_sources.gif\" create_wave_gif(sources, gif_filename) display(Image(filename=gif_filename)) files.download(gif_filename)","title":"Code and Plots"},{"location":"1%20Physics/3%20Waves/Problem_1/#colab","text":"Colab","title":"Colab"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Sector 1: Conceptual and Contextual Groundwork The Lorentz force is a fundamental principle in classical electrodynamics that governs the motion of charged particles under the influence of electric and magnetic fields. It is expressed as: \\[ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] where: - \\(q\\) is the electric charge of the particle, - \\(\\mathbf{E}\\) is the electric field vector, - \\(\\mathbf{B}\\) is the magnetic field vector, - \\(\\mathbf{v}\\) is the velocity vector of the particle. This force law is central to the operation of several modern technologies and natural phenomena. Real-World Systems Influenced by the Lorentz Force 1. Particle Accelerators In particle accelerators such as cyclotrons and synchrotrons, electric fields are used to accelerate particles, while magnetic fields guide their paths. The electric field provides work on the particle: $$ W = q\\mathbf{E} \\cdot \\mathbf{d} $$ which increases the kinetic energy: $$ \\Delta K = qE\\Delta x \\quad \\text{(for uniform } \\mathbf{E} \\text{ along } x) $$ The magnetic field bends the particle\u2019s trajectory due to the \\(\\mathbf{v} \\times \\mathbf{B}\\) term: $$ \\mathbf{F}_\\text{mag} = q\\mathbf{v} \\times \\mathbf{B} $$ If \\(\\mathbf{v} \\perp \\mathbf{B}\\) , the particle follows a circular path with radius of curvature : $$ r = \\frac{mv}{|q|B} $$ The cyclotron frequency , or Larmor frequency, is given by: $$ \\omega_c = \\frac{|q|B}{m} $$ 2. Mass Spectrometers Mass spectrometers exploit the Lorentz force to separate ions based on mass-to-charge ratio \\((m/q)\\) . After acceleration by an electric field to a velocity \\(v\\) , the ion enters a magnetic field: $$ qE = \\frac{1}{2}mv^2 \\Rightarrow v = \\sqrt{\\frac{2qV}{m}} $$ The radius of curvature in the magnetic field allows mass determination: $$ r = \\frac{mv}{qB} \\quad \\Rightarrow \\quad \\frac{m}{q} = \\frac{rB}{v} $$ 3. Plasma Confinement Devices Devices such as tokamaks and stellarators use magnetic fields to confine high-temperature plasmas. Charged particles spiral around magnetic field lines: $$ \\text{Helical motion: } \\mathbf{v} = v_\\parallel \\hat{b} + v_\\perp $$ The magnetic mirror effect occurs when field strength varies along the path: $$ \\mu = \\frac{mv_\\perp^2}{2B} \\quad \\text{(magnetic moment conserved)} $$ 4. Astrophysical Environments Charged particles in space, such as cosmic rays and solar wind ions, are deflected and guided by galactic and planetary magnetic fields. The Earth\u2019s magnetosphere traps particles in radiation belts, e.g., Van Allen belts. Drift motion arises due to inhomogeneities in \\(\\mathbf{B}\\) : \\[ \\mathbf{v}_\\text{drift} = \\frac{1}{qB^2} (\\mathbf{F}_\\text{ext} \\times \\mathbf{B}) \\] Physical Roles of Electric and Magnetic Fields Electric Fields: Acceleration and Steering An electric field performs work on a charged particle: \\[ \\mathbf{F}_\\text{elec} = q\\mathbf{E} \\] This force causes linear acceleration in the direction of the field for positive charges, and opposite for negative ones. Work-energy relation: $$ W = \\Delta K = qEd $$ In time-dependent fields, particles can be oscillated or focused using RF cavities . Magnetic Fields: Guidance and Curvature Magnetic fields do no work on charged particles since: \\[ \\mathbf{F}_\\text{mag} \\cdot \\mathbf{v} = q (\\mathbf{v} \\times \\mathbf{B}) \\cdot \\mathbf{v} = 0 \\] Instead, they alter the direction of motion, producing: Circular or helical orbits depending on velocity component parallel to \\(\\mathbf{B}\\) . Gyromotion with characteristic radius and frequency: $$ r_L = \\frac{mv_\\perp}{|q|B}, \\quad \\omega_L = \\frac{|q|B}{m} $$ Magnetic confinement by forcing charged particles to remain near field lines. These foundational concepts are critical before undertaking numerical simulations of the Lorentz force, as they inform expected behaviors and aid in validating results. Sector 2: Mathematical and Physical Modeling In order to simulate the motion of charged particles under electromagnetic influence, we must begin by rigorously formulating the equation of motion derived from classical electrodynamics. Equation of Motion The total force \\(\\mathbf{F}\\) acting on a charged particle in the presence of electric and magnetic fields is given by the Lorentz force law : \\[ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] According to Newton's second law, this force is also equal to the time derivative of momentum: \\[ \\mathbf{F} = m\\frac{d\\mathbf{v}}{dt} \\] Combining these, we obtain the fundamental equation of motion: \\[ m\\frac{d\\mathbf{v}}{dt} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] For numerical integration, this can be rewritten as a first-order system: \\[ \\frac{d\\mathbf{r}}{dt} = \\mathbf{v}, \\quad \\frac{d\\mathbf{v}}{dt} = \\frac{q}{m}(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] Numerical Methods for Integration As these differential equations are generally nonlinear and lack closed-form solutions for arbitrary field configurations, we must resort to numerical integration techniques . Two widely used methods are: 1. Euler Method The Euler method provides a first-order approximation: Velocity update: $$ \\mathbf{v}_{n+1} = \\mathbf{v}_n + \\Delta t \\cdot \\frac{q}{m}(\\mathbf{E}_n + \\mathbf{v}_n \\times \\mathbf{B}_n) $$ Position update: $$ \\mathbf{r}_{n+1} = \\mathbf{r}_n + \\Delta t \\cdot \\mathbf{v}_n $$ While simple and fast, it is only conditionally stable and prone to significant numerical error in the presence of strong magnetic fields. 2. Runge-Kutta Method (4th Order) A more accurate approach is the classical fourth-order Runge-Kutta (RK4) method. For a general system \\(\\dot{\\mathbf{y}} = \\mathbf{f}(t, \\mathbf{y})\\) , it proceeds as: \\[ \\begin{aligned} \\mathbf{k}_1 &= \\mathbf{f}(t_n, \\mathbf{y}_n) \\\\ \\mathbf{k}_2 &= \\mathbf{f}\\left(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\Delta t}{2}\\mathbf{k}_1\\right) \\\\ \\mathbf{k}_3 &= \\mathbf{f}\\left(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\Delta t}{2}\\mathbf{k}_2\\right) \\\\ \\mathbf{k}_4 &= \\mathbf{f}(t_n + \\Delta t, \\mathbf{y}_n + \\Delta t\\mathbf{k}_3) \\\\ \\mathbf{y}_{n+1} &= \\mathbf{y}_n + \\frac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4) \\end{aligned} \\] Applied to our velocity and position system, RK4 ensures higher stability and accuracy , especially when dealing with helical or oscillatory motion induced by \\(\\mathbf{B}\\) fields. Simulation Parameters To fully specify the problem, the following physical parameters must be defined prior to integration: 1. Charge ( \\(q\\) ) Determines the sign and magnitude of the Lorentz force. Common values include: - Electron: \\(q = -1.6 \\times 10^{-19}\\) C - Proton: \\(q = +1.6 \\times 10^{-19}\\) C 2. Mass ( \\(m\\) ) Inertia of the particle. Influences acceleration under applied force: - Electron: \\(m = 9.11 \\times 10^{-31}\\) kg - Proton: \\(m = 1.67 \\times 10^{-27}\\) kg 3. Initial Velocity ( \\(\\mathbf{v}_0\\) ) Vector defining the particle's initial state of motion. Components relative to the field directions ( \\(v_\\parallel\\) , \\(v_\\perp\\) ) determine motion type: - Circular ( \\(\\mathbf{v} \\perp \\mathbf{B}\\) ) - Helical (general 3D case) 4. Electric Field ( \\(\\mathbf{E}\\) ) Applied field that contributes to linear acceleration: $$ \\mathbf{F}_\\text{electric} = q\\mathbf{E} $$ Can be uniform, non-uniform, static, or time-varying. 5. Magnetic Field ( \\(\\mathbf{B}\\) ) Field responsible for transverse force: $$ \\mathbf{F}_\\text{magnetic} = q\\mathbf{v} \\times \\mathbf{B} $$ Primarily affects trajectory curvature and confinement. Together, these equations and parameters form the foundation for simulating the motion of charged particles under electromagnetic fields, enabling us to build increasingly realistic and physically accurate models. Electromagnetism: Lorentz Force Simulation We simulate the motion of a charged particle subject to electric and magnetic fields using the Lorentz Force law. Lorentz Force Law \\[ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] Using Newton's second law: \\[ m \\frac{d\\mathbf{v}}{dt} = q (\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] We also track: \\[ \\frac{d\\mathbf{r}}{dt} = \\mathbf{v} \\] We'll numerically integrate this system using the Euler method. Parameters \\(q = 1 \\, \\text{C}\\) \\(m = 0.001 \\, \\text{kg}\\) Time step \\(\\Delta t = 0.001 \\, \\text{s}\\) Number of steps: \\(N = 10000\\) Code and Plots import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # === Common Functions === def lorentz_force(q, m, E, B, v): return (q / m) * (E + np.cross(v, B)) def simulate_motion_euler(q, m, E, B, v_init, r_init, dt, num_steps): \"\"\"Euler method for general motion (used for helical and drift cases).\"\"\" v = np.array(v_init, dtype=float) r = np.array(r_init, dtype=float) trajectory = [r.copy()] for _ in range(num_steps): a = lorentz_force(q, m, E, B, v) v += a * dt r += v * dt trajectory.append(r.copy()) return np.array(trajectory) def simulate_motion_boris(q, m, E, B, v_init, r_init, dt, num_steps): \"\"\"Boris algorithm for accurate magnetic motion (preserves circularity).\"\"\" v = np.array(v_init, dtype=float) r = np.array(r_init, dtype=float) trajectory = [r.copy()] t = (q * B / m) * (0.5 * dt) t_mag2 = np.dot(t, t) s = 2 * t / (1 + t_mag2) for _ in range(num_steps): v_minus = v + (q * E / m) * (0.5 * dt) v_prime = v_minus + np.cross(v_minus, t) v_plus = v_minus + np.cross(v_prime, s) v = v_plus + (q * E / m) * (0.5 * dt) r += v * dt trajectory.append(r.copy()) return np.array(trajectory) def plot_trajectory(trajectory, title='3D Trajectory', drift_vector=None): fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(trajectory[:, 0], trajectory[:, 1], trajectory[:, 2], label='Particle Path') if drift_vector is not None: drift_line = np.outer(np.linspace(0, 10, 100), drift_vector) ax.plot(drift_line[:, 0], drift_line[:, 1], drift_line[:, 2], 'r--', label='E\u00d7B Drift') ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_zlabel('Z') ax.set_title(title) if drift_vector is not None: ax.legend() ax.grid(True) plt.tight_layout() plt.show() # === Simulation Parameters === q, m = 1.0, 1.0 # Charge and mass dt = 0.01 # Time step steps = 1000 # Number of integration steps # === Case A: Helical Motion === print(\"Running Case A: Helical Motion (Spiral in Z)\") B_A = np.array([0, 0, 1]) E_A = np.zeros(3) v0_A = [1, 0, 1] # Velocity with perpendicular and parallel components r0_A = [0, 0, 0] trajectory_A = simulate_motion_euler(q, m, E_A, B_A, v0_A, r0_A, dt, steps) plot_trajectory(trajectory_A, title='Case A: Helical Motion in Z') # === Case B: Perfect Circular Motion (Boris Method) === print(\"Running Case B: Perfect Circular Motion (Boris Method)\") B_B = np.array([0, 0, 1]) E_B = np.zeros(3) v0_B = [1, 0, 0] # Velocity strictly perpendicular to B r0_B = [0, 0, 0] trajectory_B = simulate_motion_boris(q, m, E_B, B_B, v0_B, r0_B, dt, steps) plot_trajectory(trajectory_B, title='Case B: Perfect Circular Motion (XY Plane)') # === Case C: E\u00d7B Drift === print(\"Running Case C: E\u00d7B Drift\") B_C = np.array([0, 0, 1]) E_C = np.array([1, 0, 0]) v0_C = [0, 0, 0] r0_C = [0, 0, 0] trajectory_C = simulate_motion_euler(q, m, E_C, B_C, v0_C, r0_C, dt, steps) v_drift = np.cross(E_C, B_C) / np.dot(B_C, B_C) plot_trajectory(trajectory_C, title='Case C: E\u00d7B Drift', drift_vector=v_drift) Colab","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#sector-1-conceptual-and-contextual-groundwork","text":"The Lorentz force is a fundamental principle in classical electrodynamics that governs the motion of charged particles under the influence of electric and magnetic fields. It is expressed as: \\[ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] where: - \\(q\\) is the electric charge of the particle, - \\(\\mathbf{E}\\) is the electric field vector, - \\(\\mathbf{B}\\) is the magnetic field vector, - \\(\\mathbf{v}\\) is the velocity vector of the particle. This force law is central to the operation of several modern technologies and natural phenomena.","title":"Sector 1: Conceptual and Contextual Groundwork"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#real-world-systems-influenced-by-the-lorentz-force","text":"","title":"Real-World Systems Influenced by the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-particle-accelerators","text":"In particle accelerators such as cyclotrons and synchrotrons, electric fields are used to accelerate particles, while magnetic fields guide their paths. The electric field provides work on the particle: $$ W = q\\mathbf{E} \\cdot \\mathbf{d} $$ which increases the kinetic energy: $$ \\Delta K = qE\\Delta x \\quad \\text{(for uniform } \\mathbf{E} \\text{ along } x) $$ The magnetic field bends the particle\u2019s trajectory due to the \\(\\mathbf{v} \\times \\mathbf{B}\\) term: $$ \\mathbf{F}_\\text{mag} = q\\mathbf{v} \\times \\mathbf{B} $$ If \\(\\mathbf{v} \\perp \\mathbf{B}\\) , the particle follows a circular path with radius of curvature : $$ r = \\frac{mv}{|q|B} $$ The cyclotron frequency , or Larmor frequency, is given by: $$ \\omega_c = \\frac{|q|B}{m} $$","title":"1. Particle Accelerators"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-mass-spectrometers","text":"Mass spectrometers exploit the Lorentz force to separate ions based on mass-to-charge ratio \\((m/q)\\) . After acceleration by an electric field to a velocity \\(v\\) , the ion enters a magnetic field: $$ qE = \\frac{1}{2}mv^2 \\Rightarrow v = \\sqrt{\\frac{2qV}{m}} $$ The radius of curvature in the magnetic field allows mass determination: $$ r = \\frac{mv}{qB} \\quad \\Rightarrow \\quad \\frac{m}{q} = \\frac{rB}{v} $$","title":"2. Mass Spectrometers"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-plasma-confinement-devices","text":"Devices such as tokamaks and stellarators use magnetic fields to confine high-temperature plasmas. Charged particles spiral around magnetic field lines: $$ \\text{Helical motion: } \\mathbf{v} = v_\\parallel \\hat{b} + v_\\perp $$ The magnetic mirror effect occurs when field strength varies along the path: $$ \\mu = \\frac{mv_\\perp^2}{2B} \\quad \\text{(magnetic moment conserved)} $$","title":"3. Plasma Confinement Devices"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-astrophysical-environments","text":"Charged particles in space, such as cosmic rays and solar wind ions, are deflected and guided by galactic and planetary magnetic fields. The Earth\u2019s magnetosphere traps particles in radiation belts, e.g., Van Allen belts. Drift motion arises due to inhomogeneities in \\(\\mathbf{B}\\) : \\[ \\mathbf{v}_\\text{drift} = \\frac{1}{qB^2} (\\mathbf{F}_\\text{ext} \\times \\mathbf{B}) \\]","title":"4. Astrophysical Environments"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#physical-roles-of-electric-and-magnetic-fields","text":"","title":"Physical Roles of Electric and Magnetic Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#electric-fields-acceleration-and-steering","text":"An electric field performs work on a charged particle: \\[ \\mathbf{F}_\\text{elec} = q\\mathbf{E} \\] This force causes linear acceleration in the direction of the field for positive charges, and opposite for negative ones. Work-energy relation: $$ W = \\Delta K = qEd $$ In time-dependent fields, particles can be oscillated or focused using RF cavities .","title":"Electric Fields: Acceleration and Steering"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#magnetic-fields-guidance-and-curvature","text":"Magnetic fields do no work on charged particles since: \\[ \\mathbf{F}_\\text{mag} \\cdot \\mathbf{v} = q (\\mathbf{v} \\times \\mathbf{B}) \\cdot \\mathbf{v} = 0 \\] Instead, they alter the direction of motion, producing: Circular or helical orbits depending on velocity component parallel to \\(\\mathbf{B}\\) . Gyromotion with characteristic radius and frequency: $$ r_L = \\frac{mv_\\perp}{|q|B}, \\quad \\omega_L = \\frac{|q|B}{m} $$ Magnetic confinement by forcing charged particles to remain near field lines. These foundational concepts are critical before undertaking numerical simulations of the Lorentz force, as they inform expected behaviors and aid in validating results.","title":"Magnetic Fields: Guidance and Curvature"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#sector-2-mathematical-and-physical-modeling","text":"In order to simulate the motion of charged particles under electromagnetic influence, we must begin by rigorously formulating the equation of motion derived from classical electrodynamics.","title":"Sector 2: Mathematical and Physical Modeling"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#equation-of-motion","text":"The total force \\(\\mathbf{F}\\) acting on a charged particle in the presence of electric and magnetic fields is given by the Lorentz force law : \\[ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] According to Newton's second law, this force is also equal to the time derivative of momentum: \\[ \\mathbf{F} = m\\frac{d\\mathbf{v}}{dt} \\] Combining these, we obtain the fundamental equation of motion: \\[ m\\frac{d\\mathbf{v}}{dt} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] For numerical integration, this can be rewritten as a first-order system: \\[ \\frac{d\\mathbf{r}}{dt} = \\mathbf{v}, \\quad \\frac{d\\mathbf{v}}{dt} = \\frac{q}{m}(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\]","title":"Equation of Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#numerical-methods-for-integration","text":"As these differential equations are generally nonlinear and lack closed-form solutions for arbitrary field configurations, we must resort to numerical integration techniques . Two widely used methods are:","title":"Numerical Methods for Integration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-euler-method","text":"The Euler method provides a first-order approximation: Velocity update: $$ \\mathbf{v}_{n+1} = \\mathbf{v}_n + \\Delta t \\cdot \\frac{q}{m}(\\mathbf{E}_n + \\mathbf{v}_n \\times \\mathbf{B}_n) $$ Position update: $$ \\mathbf{r}_{n+1} = \\mathbf{r}_n + \\Delta t \\cdot \\mathbf{v}_n $$ While simple and fast, it is only conditionally stable and prone to significant numerical error in the presence of strong magnetic fields.","title":"1. Euler Method"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-runge-kutta-method-4th-order","text":"A more accurate approach is the classical fourth-order Runge-Kutta (RK4) method. For a general system \\(\\dot{\\mathbf{y}} = \\mathbf{f}(t, \\mathbf{y})\\) , it proceeds as: \\[ \\begin{aligned} \\mathbf{k}_1 &= \\mathbf{f}(t_n, \\mathbf{y}_n) \\\\ \\mathbf{k}_2 &= \\mathbf{f}\\left(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\Delta t}{2}\\mathbf{k}_1\\right) \\\\ \\mathbf{k}_3 &= \\mathbf{f}\\left(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\Delta t}{2}\\mathbf{k}_2\\right) \\\\ \\mathbf{k}_4 &= \\mathbf{f}(t_n + \\Delta t, \\mathbf{y}_n + \\Delta t\\mathbf{k}_3) \\\\ \\mathbf{y}_{n+1} &= \\mathbf{y}_n + \\frac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4) \\end{aligned} \\] Applied to our velocity and position system, RK4 ensures higher stability and accuracy , especially when dealing with helical or oscillatory motion induced by \\(\\mathbf{B}\\) fields.","title":"2. Runge-Kutta Method (4th Order)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulation-parameters","text":"To fully specify the problem, the following physical parameters must be defined prior to integration:","title":"Simulation Parameters"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-charge-q","text":"Determines the sign and magnitude of the Lorentz force. Common values include: - Electron: \\(q = -1.6 \\times 10^{-19}\\) C - Proton: \\(q = +1.6 \\times 10^{-19}\\) C","title":"1. Charge (\\(q\\))"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-mass-m","text":"Inertia of the particle. Influences acceleration under applied force: - Electron: \\(m = 9.11 \\times 10^{-31}\\) kg - Proton: \\(m = 1.67 \\times 10^{-27}\\) kg","title":"2. Mass (\\(m\\))"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-initial-velocity-mathbfv_0","text":"Vector defining the particle's initial state of motion. Components relative to the field directions ( \\(v_\\parallel\\) , \\(v_\\perp\\) ) determine motion type: - Circular ( \\(\\mathbf{v} \\perp \\mathbf{B}\\) ) - Helical (general 3D case)","title":"3. Initial Velocity (\\(\\mathbf{v}_0\\))"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-electric-field-mathbfe","text":"Applied field that contributes to linear acceleration: $$ \\mathbf{F}_\\text{electric} = q\\mathbf{E} $$ Can be uniform, non-uniform, static, or time-varying.","title":"4. Electric Field (\\(\\mathbf{E}\\))"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-magnetic-field-mathbfb","text":"Field responsible for transverse force: $$ \\mathbf{F}_\\text{magnetic} = q\\mathbf{v} \\times \\mathbf{B} $$ Primarily affects trajectory curvature and confinement. Together, these equations and parameters form the foundation for simulating the motion of charged particles under electromagnetic fields, enabling us to build increasingly realistic and physically accurate models.","title":"5. Magnetic Field (\\(\\mathbf{B}\\))"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#electromagnetism-lorentz-force-simulation","text":"We simulate the motion of a charged particle subject to electric and magnetic fields using the Lorentz Force law.","title":"Electromagnetism: Lorentz Force Simulation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#lorentz-force-law","text":"\\[ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] Using Newton's second law: \\[ m \\frac{d\\mathbf{v}}{dt} = q (\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] We also track: \\[ \\frac{d\\mathbf{r}}{dt} = \\mathbf{v} \\] We'll numerically integrate this system using the Euler method.","title":"Lorentz Force Law"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#parameters","text":"\\(q = 1 \\, \\text{C}\\) \\(m = 0.001 \\, \\text{kg}\\) Time step \\(\\Delta t = 0.001 \\, \\text{s}\\) Number of steps: \\(N = 10000\\)","title":"Parameters"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#code-and-plots","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # === Common Functions === def lorentz_force(q, m, E, B, v): return (q / m) * (E + np.cross(v, B)) def simulate_motion_euler(q, m, E, B, v_init, r_init, dt, num_steps): \"\"\"Euler method for general motion (used for helical and drift cases).\"\"\" v = np.array(v_init, dtype=float) r = np.array(r_init, dtype=float) trajectory = [r.copy()] for _ in range(num_steps): a = lorentz_force(q, m, E, B, v) v += a * dt r += v * dt trajectory.append(r.copy()) return np.array(trajectory) def simulate_motion_boris(q, m, E, B, v_init, r_init, dt, num_steps): \"\"\"Boris algorithm for accurate magnetic motion (preserves circularity).\"\"\" v = np.array(v_init, dtype=float) r = np.array(r_init, dtype=float) trajectory = [r.copy()] t = (q * B / m) * (0.5 * dt) t_mag2 = np.dot(t, t) s = 2 * t / (1 + t_mag2) for _ in range(num_steps): v_minus = v + (q * E / m) * (0.5 * dt) v_prime = v_minus + np.cross(v_minus, t) v_plus = v_minus + np.cross(v_prime, s) v = v_plus + (q * E / m) * (0.5 * dt) r += v * dt trajectory.append(r.copy()) return np.array(trajectory) def plot_trajectory(trajectory, title='3D Trajectory', drift_vector=None): fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(trajectory[:, 0], trajectory[:, 1], trajectory[:, 2], label='Particle Path') if drift_vector is not None: drift_line = np.outer(np.linspace(0, 10, 100), drift_vector) ax.plot(drift_line[:, 0], drift_line[:, 1], drift_line[:, 2], 'r--', label='E\u00d7B Drift') ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_zlabel('Z') ax.set_title(title) if drift_vector is not None: ax.legend() ax.grid(True) plt.tight_layout() plt.show() # === Simulation Parameters === q, m = 1.0, 1.0 # Charge and mass dt = 0.01 # Time step steps = 1000 # Number of integration steps # === Case A: Helical Motion === print(\"Running Case A: Helical Motion (Spiral in Z)\") B_A = np.array([0, 0, 1]) E_A = np.zeros(3) v0_A = [1, 0, 1] # Velocity with perpendicular and parallel components r0_A = [0, 0, 0] trajectory_A = simulate_motion_euler(q, m, E_A, B_A, v0_A, r0_A, dt, steps) plot_trajectory(trajectory_A, title='Case A: Helical Motion in Z') # === Case B: Perfect Circular Motion (Boris Method) === print(\"Running Case B: Perfect Circular Motion (Boris Method)\") B_B = np.array([0, 0, 1]) E_B = np.zeros(3) v0_B = [1, 0, 0] # Velocity strictly perpendicular to B r0_B = [0, 0, 0] trajectory_B = simulate_motion_boris(q, m, E_B, B_B, v0_B, r0_B, dt, steps) plot_trajectory(trajectory_B, title='Case B: Perfect Circular Motion (XY Plane)') # === Case C: E\u00d7B Drift === print(\"Running Case C: E\u00d7B Drift\") B_C = np.array([0, 0, 1]) E_C = np.array([1, 0, 0]) v0_C = [0, 0, 0] r0_C = [0, 0, 0] trajectory_C = simulate_motion_euler(q, m, E_C, B_C, v0_C, r0_C, dt, steps) v_drift = np.cross(E_C, B_C) / np.dot(B_C, B_C) plot_trajectory(trajectory_C, title='Case C: E\u00d7B Drift', drift_vector=v_drift) Colab","title":"Code and Plots"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Sector 1: Problem Understanding and Setup Graph Representation To analyze the circuit as a graph, we define: Nodes ( \\(V\\) ) as the junction points of the circuit. Edges ( \\(E\\) ) as the resistors connecting nodes. Each edge \\(e \\in E\\) has an associated weight \\(w(e)\\) representing the resistance value \\(R\\) of the resistor. Thus, the circuit can be modeled as an undirected weighted graph: $$ G = (V, E, w) $$ where - \\(V = \\{v_1, v_2, \\ldots, v_n\\}\\) , - \\(E = \\{e_{ij} | v_i \\text{ connected to } v_j\\}\\) , - \\(w : E \\to \\mathbb{R}^+\\) such that \\(w(e_{ij}) = R_{ij} > 0\\) . Input Format Specification The input graph can be represented in several ways, depending on the use case: Adjacency List : For each node \\(v_i\\) , list all adjacent nodes \\(v_j\\) along with weights \\(R_{ij}\\) . $$ \\text{AdjacencyList}(v_i) = { (v_j, R_{ij}) \\mid (v_i, v_j) \\in E } $$ Edge List with Weights : A list of tuples \\((v_i, v_j, R_{ij})\\) . $$ E = { (v_i, v_j, R_{ij}) \\mid i,j = 1, \\ldots, n } $$ Adjacency Matrix ( \\(\\mathbf{A}\\) ) : A matrix of size \\(n \\times n\\) where each element \\(A_{ij}\\) corresponds to the resistance value \\(R_{ij}\\) if nodes are connected, or zero otherwise: $$ A_{ij} = \\begin{cases} R_{ij} & \\text{if } (v_i, v_j) \\in E, \\ 0 & \\text{otherwise}. \\end{cases} $$ Graph Properties We assume the following properties for the circuit graph: Undirected edges : The graph \\(G\\) is undirected, so $$ (v_i, v_j) \\in E \\implies (v_j, v_i) \\in E, $$ and resistance weights are symmetric: $$ R_{ij} = R_{ji}. $$ Positive resistance weights : $$ R_{ij} > 0, \\quad \\forall (v_i, v_j) \\in E. $$ Connected graph : There exists at least one path between every pair of nodes \\(v_i\\) and \\(v_j\\) , ensuring the graph is connected: $$ \\forall v_i, v_j \\in V, \\quad \\exists \\text{ path } P = (v_i, \\ldots, v_j). $$ Task Scope Selection Given the problem scope, choose one of the following options: Option 1: Develop detailed pseudocode and describe the algorithmic approach for analyzing the circuit graph. Option 2: Provide a full implementation including input parsing, graph construction, and testing with sample circuit graphs. Sector 2: Algorithm Design Design Series Detection To identify series resistor chains , we look for nodes with degree 2 (connected to exactly two edges): Let \\(v_k \\in V\\) be a node such that $$ \\deg(v_k) = 2, $$ where \\(\\deg(v_k)\\) is the degree of node \\(v_k\\) . The two edges connected to \\(v_k\\) are \\(e_{ik} = (v_i, v_k)\\) and \\(e_{kj} = (v_k, v_j)\\) with resistances \\(R_{ik}\\) and \\(R_{kj}\\) respectively. Since these resistors are in series, they can be reduced to a single equivalent resistor: $$ R_{\\text{series}} = R_{ik} + R_{kj}. $$ The series reduction replaces edges \\((v_i, v_k)\\) and \\((v_k, v_j)\\) by a single edge \\((v_i, v_j)\\) with weight \\(R_{\\text{series}}\\) , and removes node \\(v_k\\) from \\(V\\) . Design Parallel Detection To detect parallel resistor connections , identify multiple edges connecting the same pair of nodes: For nodes \\(v_i, v_j \\in V\\) , suppose there are \\(m\\) parallel edges: $$ {e_{ij}^1, e_{ij}^2, \\ldots, e_{ij}^m}, $$ with resistances $$ R_{ij}^1, R_{ij}^2, \\ldots, R_{ij}^m. $$ The equivalent resistance of parallel resistors is given by the reciprocal sum: $$ \\frac{1}{R_{\\text{parallel}}} = \\sum_{k=1}^m \\frac{1}{R_{ij}^k}. $$ The parallel edges are replaced by a single edge \\((v_i, v_j)\\) with weight \\(R_{\\text{parallel}}\\) . Additionally, parallel connections may appear as small cycles, requiring cycle detection algorithms. Outline Reduction Strategy The graph reduction algorithm iteratively applies series and parallel reductions: Initialize with graph \\(G = (V, E, w)\\) . While the graph has more than one edge: Detect series nodes ( \\(\\deg = 2\\) ) and reduce. Detect parallel edges and reduce. Repeat until \\(G\\) reduces to a single edge between two nodes representing the equivalent resistance \\(R_{\\text{eq}}\\) . Formally, $$ G^{(0)} = G, \\quad G^{(t+1)} = \\text{Reduce}(G^{(t)}), $$ with termination condition $$ |E^{(t)}| = 1. $$ Plan for Nested Configurations Nested series-parallel configurations require careful tracking: Use recursive reduction or stack-based tracking to handle nested subgraphs. Maintain mapping of original nodes and edges to reduced edges to preserve circuit integrity. Ensure reduction respects: $$ R_{\\text{eq}} = \\text{series/parallel composition of nested resistors}. $$ Define Termination Condition The reduction process ends when: The graph is simplified to a single edge \\(e_{\\text{final}}\\) connecting two terminal nodes \\(v_s\\) and \\(v_t\\) : $$ G_{\\text{final}} = ( {v_s, v_t}, {e_{\\text{final}}} ), $$ where \\(w(e_{\\text{final}}) = R_{\\text{eq}}\\) . Select Traversal Method Choose a traversal technique to identify reducible patterns systematically: Depth-First Search (DFS) : Useful for exploring cycles and nested subgraphs. Efficient for detecting series chains by node degree inspection. Breadth-First Search (BFS) : Useful for level-order traversal, detecting parallel connections early. In this context, DFS is generally preferred to explore connected components and nested structures: \\[ \\text{DFS}(v) : \\text{explore all adjacent nodes recursively from } v. \\] Code and Plots # Install necessary packages for Colab !pip install networkx matplotlib pillow -q import os import shutil import networkx as nx import matplotlib.pyplot as plt from PIL import Image # Create folder for frames if os.path.exists(\"frames\"): shutil.rmtree(\"frames\") os.makedirs(\"frames\") # Step-by-step simplification colors colors = [\"red\", \"green\", \"blue\", \"purple\", \"orange\"] # Define the initial circuit graph def create_initial_circuit(): G = nx.Graph() G.add_edges_from([ (\"B+\", \"R1\"), (\"R1\", \"R2\"), (\"R2\", \"R3\"), (\"R3\", \"R4\"), (\"R2\", \"R5\"), (\"R3\", \"R6\"), (\"R5\", \"R6\"), (\"R4\", \"B-\") ]) return G # Layout for reproducibility pos_layout = { \"B+\": (0, 1), \"R1\": (1, 1), \"R2\": (2, 1), \"R5\": (2, 0), \"R6\": (3, 0), \"R3\": (3, 1), \"R4\": (4, 1), \"B-\": (5, 1) } # Draw and save a frame of the circuit def draw_circuit(G, highlight_edges=[], highlight_color=\"red\", step=0, label=\"\"): plt.figure(figsize=(8, 4)) edge_colors = [highlight_color if e in highlight_edges or (e[1], e[0]) in highlight_edges else 'black' for e in G.edges()] nx.draw(G, pos=pos_layout, with_labels=True, node_color='lightgrey', edge_color=edge_colors, node_size=1000, font_weight='bold') plt.title(f\"Step {step}: {label}\") plt.axis('off') plt.savefig(f\"frames/frame_{step:02d}.png\") plt.close() # Start simplification process G = create_initial_circuit() # Step 0: Original draw_circuit(G, step=0, label=\"Original Circuit\") # Step 1: Combine R5 and R6 (parallel) -> R56 G = nx.contracted_nodes(G, \"R5\", \"R6\", self_loops=False) G = nx.relabel_nodes(G, {\"R5\": \"R56\"}) pos_layout[\"R56\"] = (2.5, 0) pos_layout.pop(\"R6\") draw_circuit(G, highlight_edges=[(\"R2\", \"R56\"), (\"R56\", \"R3\")], highlight_color=colors[0], step=1, label=\"Parallel: R5 and R6 -> R56\") # Step 2: Combine R2 and R56 (series) -> R256 G = nx.contracted_nodes(G, \"R2\", \"R56\", self_loops=False) G = nx.relabel_nodes(G, {\"R2\": \"R256\"}) pos_layout[\"R256\"] = (2.25, 0.75) pos_layout.pop(\"R56\") draw_circuit(G, highlight_edges=[(\"R1\", \"R256\"), (\"R256\", \"R3\")], highlight_color=colors[1], step=2, label=\"Series: R2 and R56 -> R256\") # Step 3: Combine R1 and R256 (series) -> R1256 G = nx.contracted_nodes(G, \"R1\", \"R256\", self_loops=False) G = nx.relabel_nodes(G, {\"R1\": \"R1256\"}) pos_layout[\"R1256\"] = (1.5, 1) pos_layout.pop(\"R256\") draw_circuit(G, highlight_edges=[(\"B+\", \"R1256\"), (\"R1256\", \"R3\")], highlight_color=colors[2], step=3, label=\"Series: R1 and R256 -> R1256\") # Step 4: Combine R3 and R4 (series) -> R34 G = nx.contracted_nodes(G, \"R3\", \"R4\", self_loops=False) G = nx.relabel_nodes(G, {\"R3\": \"R34\"}) pos_layout[\"R34\"] = (3.5, 1) pos_layout.pop(\"R4\") draw_circuit(G, highlight_edges=[(\"R1256\", \"R34\"), (\"R34\", \"B-\")], highlight_color=colors[3], step=4, label=\"Series: R3 and R4 -> R34\") # Step 5: Final Combine R1256 and R34 -> Rfinal G = nx.contracted_nodes(G, \"R1256\", \"R34\", self_loops=False) G = nx.relabel_nodes(G, {\"R1256\": \"Rfinal\"}) pos_layout[\"Rfinal\"] = (2.5, 1) pos_layout.pop(\"R34\") draw_circuit(G, highlight_edges=[(\"B+\", \"Rfinal\"), (\"Rfinal\", \"B-\")], highlight_color=colors[4], step=5, label=\"Final: R1256 and R34 -> Rfinal\") # Create GIF from frames frames = [Image.open(f\"frames/{frame}\") for frame in sorted(os.listdir(\"frames\")) if frame.endswith(\".png\")] frames[0].save(\"circuit_simplification.gif\", format='GIF', append_images=frames[1:], save_all=True, duration=1000, loop=0) # Clean up frame directory shutil.rmtree(\"frames\") # Display the GIF in Colab from IPython.display import Image as IPyImage IPyImage(filename=\"circuit_simplification.gif\") Colab","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#sector-1-problem-understanding-and-setup","text":"","title":"Sector 1: Problem Understanding and Setup"},{"location":"1%20Physics/5%20Circuits/Problem_1/#graph-representation","text":"To analyze the circuit as a graph, we define: Nodes ( \\(V\\) ) as the junction points of the circuit. Edges ( \\(E\\) ) as the resistors connecting nodes. Each edge \\(e \\in E\\) has an associated weight \\(w(e)\\) representing the resistance value \\(R\\) of the resistor. Thus, the circuit can be modeled as an undirected weighted graph: $$ G = (V, E, w) $$ where - \\(V = \\{v_1, v_2, \\ldots, v_n\\}\\) , - \\(E = \\{e_{ij} | v_i \\text{ connected to } v_j\\}\\) , - \\(w : E \\to \\mathbb{R}^+\\) such that \\(w(e_{ij}) = R_{ij} > 0\\) .","title":"Graph Representation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#input-format-specification","text":"The input graph can be represented in several ways, depending on the use case: Adjacency List : For each node \\(v_i\\) , list all adjacent nodes \\(v_j\\) along with weights \\(R_{ij}\\) . $$ \\text{AdjacencyList}(v_i) = { (v_j, R_{ij}) \\mid (v_i, v_j) \\in E } $$ Edge List with Weights : A list of tuples \\((v_i, v_j, R_{ij})\\) . $$ E = { (v_i, v_j, R_{ij}) \\mid i,j = 1, \\ldots, n } $$ Adjacency Matrix ( \\(\\mathbf{A}\\) ) : A matrix of size \\(n \\times n\\) where each element \\(A_{ij}\\) corresponds to the resistance value \\(R_{ij}\\) if nodes are connected, or zero otherwise: $$ A_{ij} = \\begin{cases} R_{ij} & \\text{if } (v_i, v_j) \\in E, \\ 0 & \\text{otherwise}. \\end{cases} $$","title":"Input Format Specification"},{"location":"1%20Physics/5%20Circuits/Problem_1/#graph-properties","text":"We assume the following properties for the circuit graph: Undirected edges : The graph \\(G\\) is undirected, so $$ (v_i, v_j) \\in E \\implies (v_j, v_i) \\in E, $$ and resistance weights are symmetric: $$ R_{ij} = R_{ji}. $$ Positive resistance weights : $$ R_{ij} > 0, \\quad \\forall (v_i, v_j) \\in E. $$ Connected graph : There exists at least one path between every pair of nodes \\(v_i\\) and \\(v_j\\) , ensuring the graph is connected: $$ \\forall v_i, v_j \\in V, \\quad \\exists \\text{ path } P = (v_i, \\ldots, v_j). $$","title":"Graph Properties"},{"location":"1%20Physics/5%20Circuits/Problem_1/#task-scope-selection","text":"Given the problem scope, choose one of the following options: Option 1: Develop detailed pseudocode and describe the algorithmic approach for analyzing the circuit graph. Option 2: Provide a full implementation including input parsing, graph construction, and testing with sample circuit graphs.","title":"Task Scope Selection"},{"location":"1%20Physics/5%20Circuits/Problem_1/#sector-2-algorithm-design","text":"","title":"Sector 2: Algorithm Design"},{"location":"1%20Physics/5%20Circuits/Problem_1/#design-series-detection","text":"To identify series resistor chains , we look for nodes with degree 2 (connected to exactly two edges): Let \\(v_k \\in V\\) be a node such that $$ \\deg(v_k) = 2, $$ where \\(\\deg(v_k)\\) is the degree of node \\(v_k\\) . The two edges connected to \\(v_k\\) are \\(e_{ik} = (v_i, v_k)\\) and \\(e_{kj} = (v_k, v_j)\\) with resistances \\(R_{ik}\\) and \\(R_{kj}\\) respectively. Since these resistors are in series, they can be reduced to a single equivalent resistor: $$ R_{\\text{series}} = R_{ik} + R_{kj}. $$ The series reduction replaces edges \\((v_i, v_k)\\) and \\((v_k, v_j)\\) by a single edge \\((v_i, v_j)\\) with weight \\(R_{\\text{series}}\\) , and removes node \\(v_k\\) from \\(V\\) .","title":"Design Series Detection"},{"location":"1%20Physics/5%20Circuits/Problem_1/#design-parallel-detection","text":"To detect parallel resistor connections , identify multiple edges connecting the same pair of nodes: For nodes \\(v_i, v_j \\in V\\) , suppose there are \\(m\\) parallel edges: $$ {e_{ij}^1, e_{ij}^2, \\ldots, e_{ij}^m}, $$ with resistances $$ R_{ij}^1, R_{ij}^2, \\ldots, R_{ij}^m. $$ The equivalent resistance of parallel resistors is given by the reciprocal sum: $$ \\frac{1}{R_{\\text{parallel}}} = \\sum_{k=1}^m \\frac{1}{R_{ij}^k}. $$ The parallel edges are replaced by a single edge \\((v_i, v_j)\\) with weight \\(R_{\\text{parallel}}\\) . Additionally, parallel connections may appear as small cycles, requiring cycle detection algorithms.","title":"Design Parallel Detection"},{"location":"1%20Physics/5%20Circuits/Problem_1/#outline-reduction-strategy","text":"The graph reduction algorithm iteratively applies series and parallel reductions: Initialize with graph \\(G = (V, E, w)\\) . While the graph has more than one edge: Detect series nodes ( \\(\\deg = 2\\) ) and reduce. Detect parallel edges and reduce. Repeat until \\(G\\) reduces to a single edge between two nodes representing the equivalent resistance \\(R_{\\text{eq}}\\) . Formally, $$ G^{(0)} = G, \\quad G^{(t+1)} = \\text{Reduce}(G^{(t)}), $$ with termination condition $$ |E^{(t)}| = 1. $$","title":"Outline Reduction Strategy"},{"location":"1%20Physics/5%20Circuits/Problem_1/#plan-for-nested-configurations","text":"Nested series-parallel configurations require careful tracking: Use recursive reduction or stack-based tracking to handle nested subgraphs. Maintain mapping of original nodes and edges to reduced edges to preserve circuit integrity. Ensure reduction respects: $$ R_{\\text{eq}} = \\text{series/parallel composition of nested resistors}. $$","title":"Plan for Nested Configurations"},{"location":"1%20Physics/5%20Circuits/Problem_1/#define-termination-condition","text":"The reduction process ends when: The graph is simplified to a single edge \\(e_{\\text{final}}\\) connecting two terminal nodes \\(v_s\\) and \\(v_t\\) : $$ G_{\\text{final}} = ( {v_s, v_t}, {e_{\\text{final}}} ), $$ where \\(w(e_{\\text{final}}) = R_{\\text{eq}}\\) .","title":"Define Termination Condition"},{"location":"1%20Physics/5%20Circuits/Problem_1/#select-traversal-method","text":"Choose a traversal technique to identify reducible patterns systematically: Depth-First Search (DFS) : Useful for exploring cycles and nested subgraphs. Efficient for detecting series chains by node degree inspection. Breadth-First Search (BFS) : Useful for level-order traversal, detecting parallel connections early. In this context, DFS is generally preferred to explore connected components and nested structures: \\[ \\text{DFS}(v) : \\text{explore all adjacent nodes recursively from } v. \\]","title":"Select Traversal Method"},{"location":"1%20Physics/5%20Circuits/Problem_1/#code-and-plots","text":"# Install necessary packages for Colab !pip install networkx matplotlib pillow -q import os import shutil import networkx as nx import matplotlib.pyplot as plt from PIL import Image # Create folder for frames if os.path.exists(\"frames\"): shutil.rmtree(\"frames\") os.makedirs(\"frames\") # Step-by-step simplification colors colors = [\"red\", \"green\", \"blue\", \"purple\", \"orange\"] # Define the initial circuit graph def create_initial_circuit(): G = nx.Graph() G.add_edges_from([ (\"B+\", \"R1\"), (\"R1\", \"R2\"), (\"R2\", \"R3\"), (\"R3\", \"R4\"), (\"R2\", \"R5\"), (\"R3\", \"R6\"), (\"R5\", \"R6\"), (\"R4\", \"B-\") ]) return G # Layout for reproducibility pos_layout = { \"B+\": (0, 1), \"R1\": (1, 1), \"R2\": (2, 1), \"R5\": (2, 0), \"R6\": (3, 0), \"R3\": (3, 1), \"R4\": (4, 1), \"B-\": (5, 1) } # Draw and save a frame of the circuit def draw_circuit(G, highlight_edges=[], highlight_color=\"red\", step=0, label=\"\"): plt.figure(figsize=(8, 4)) edge_colors = [highlight_color if e in highlight_edges or (e[1], e[0]) in highlight_edges else 'black' for e in G.edges()] nx.draw(G, pos=pos_layout, with_labels=True, node_color='lightgrey', edge_color=edge_colors, node_size=1000, font_weight='bold') plt.title(f\"Step {step}: {label}\") plt.axis('off') plt.savefig(f\"frames/frame_{step:02d}.png\") plt.close() # Start simplification process G = create_initial_circuit() # Step 0: Original draw_circuit(G, step=0, label=\"Original Circuit\") # Step 1: Combine R5 and R6 (parallel) -> R56 G = nx.contracted_nodes(G, \"R5\", \"R6\", self_loops=False) G = nx.relabel_nodes(G, {\"R5\": \"R56\"}) pos_layout[\"R56\"] = (2.5, 0) pos_layout.pop(\"R6\") draw_circuit(G, highlight_edges=[(\"R2\", \"R56\"), (\"R56\", \"R3\")], highlight_color=colors[0], step=1, label=\"Parallel: R5 and R6 -> R56\") # Step 2: Combine R2 and R56 (series) -> R256 G = nx.contracted_nodes(G, \"R2\", \"R56\", self_loops=False) G = nx.relabel_nodes(G, {\"R2\": \"R256\"}) pos_layout[\"R256\"] = (2.25, 0.75) pos_layout.pop(\"R56\") draw_circuit(G, highlight_edges=[(\"R1\", \"R256\"), (\"R256\", \"R3\")], highlight_color=colors[1], step=2, label=\"Series: R2 and R56 -> R256\") # Step 3: Combine R1 and R256 (series) -> R1256 G = nx.contracted_nodes(G, \"R1\", \"R256\", self_loops=False) G = nx.relabel_nodes(G, {\"R1\": \"R1256\"}) pos_layout[\"R1256\"] = (1.5, 1) pos_layout.pop(\"R256\") draw_circuit(G, highlight_edges=[(\"B+\", \"R1256\"), (\"R1256\", \"R3\")], highlight_color=colors[2], step=3, label=\"Series: R1 and R256 -> R1256\") # Step 4: Combine R3 and R4 (series) -> R34 G = nx.contracted_nodes(G, \"R3\", \"R4\", self_loops=False) G = nx.relabel_nodes(G, {\"R3\": \"R34\"}) pos_layout[\"R34\"] = (3.5, 1) pos_layout.pop(\"R4\") draw_circuit(G, highlight_edges=[(\"R1256\", \"R34\"), (\"R34\", \"B-\")], highlight_color=colors[3], step=4, label=\"Series: R3 and R4 -> R34\") # Step 5: Final Combine R1256 and R34 -> Rfinal G = nx.contracted_nodes(G, \"R1256\", \"R34\", self_loops=False) G = nx.relabel_nodes(G, {\"R1256\": \"Rfinal\"}) pos_layout[\"Rfinal\"] = (2.5, 1) pos_layout.pop(\"R34\") draw_circuit(G, highlight_edges=[(\"B+\", \"Rfinal\"), (\"Rfinal\", \"B-\")], highlight_color=colors[4], step=5, label=\"Final: R1256 and R34 -> Rfinal\") # Create GIF from frames frames = [Image.open(f\"frames/{frame}\") for frame in sorted(os.listdir(\"frames\")) if frame.endswith(\".png\")] frames[0].save(\"circuit_simplification.gif\", format='GIF', append_images=frames[1:], save_all=True, duration=1000, loop=0) # Clean up frame directory shutil.rmtree(\"frames\") # Display the GIF in Colab from IPython.display import Image as IPyImage IPyImage(filename=\"circuit_simplification.gif\") Colab","title":"Code and Plots"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 Data Generation in Statistical Analysis Data generation is a foundational step in statistical modeling and simulation. Selecting appropriate population distribution types and generating large datasets representative of those populations is crucial for valid inference. Population Distributions Consider three common types of population distributions: 1. Uniform Distribution A continuous uniform distribution on the interval \\([a, b]\\) has the probability density function (PDF): \\[ f_X(x) = \\frac{1}{b - a}, \\quad a \\leq x \\leq b \\] The cumulative distribution function (CDF) is: \\[ F_X(x) = \\frac{x - a}{b - a}, \\quad a \\leq x \\leq b \\] To generate a dataset \\(\\{X_i\\}_{i=1}^n\\) from a uniform distribution, sample \\(n\\) independent observations where \\[ X_i \\sim \\text{Uniform}(a, b), \\quad i = 1, 2, \\ldots, n \\] 2. Exponential Distribution The exponential distribution is often used to model waiting times and has PDF: \\[ f_X(x) = \\lambda e^{-\\lambda x}, \\quad x \\geq 0, \\lambda > 0 \\] where \\(\\lambda\\) is the rate parameter. The CDF is: \\[ F_X(x) = 1 - e^{-\\lambda x}, \\quad x \\geq 0 \\] Generate \\(n\\) samples from \\[ X_i \\sim \\text{Exponential}(\\lambda), \\quad i = 1, 2, \\ldots, n \\] 3. Binomial Distribution The binomial distribution models the number of successes in \\(n\\) independent Bernoulli trials, each with success probability \\(p\\) . The probability mass function (PMF) is: \\[ P(X = k) = \\binom{n}{k} p^k (1-p)^{n-k}, \\quad k = 0, 1, \\ldots, n \\] To generate data, \\[ X_i \\sim \\text{Binomial}(n, p), \\quad i = 1, 2, \\ldots, m \\] where \\(m\\) is the number of generated observations. Generating Large Datasets Given a selected population distribution, generate a large dataset to approximate the population: Fix distribution parameters (e.g., \\(a,b\\) for uniform, \\(\\lambda\\) for exponential, \\(n,p\\) for binomial). Select a sample size \\(N\\) sufficiently large to represent the population well. Use random number generation methods to simulate: \\[ \\{X_i\\}_{i=1}^N \\sim \\text{Distribution}(\\text{parameters}) \\] This process provides a simulated population for analysis. Summary Distribution Parameters Support PDF / PMF Uniform \\(a, b\\) \\([a,b]\\) \\(f_X(x) = \\frac{1}{b - a}\\) Exponential \\(\\lambda > 0\\) \\([0, \\infty)\\) \\(f_X(x) = \\lambda e^{-\\lambda x}\\) Binomial \\(n \\in \\mathbb{N}\\) , \\(p \\in [0,1]\\) \\(\\{0,\\ldots,n\\}\\) \\(P(X=k) = \\binom{n}{k} p^k (1-p)^{n-k}\\) Example: Generating Data Suppose we want to generate \\(N=10,000\\) samples from a uniform distribution on \\([0,1]\\) : \\[ X_i \\sim \\text{Uniform}(0,1), \\quad i=1,\\ldots, 10000 \\] Similarly, for exponential with \\(\\lambda=2\\) : \\[ X_i \\sim \\text{Exponential}(2), \\quad i=1,\\ldots, 10000 \\] And binomial with \\(n=10\\) , \\(p=0.5\\) : \\[ X_i \\sim \\text{Binomial}(10, 0.5), \\quad i=1,\\ldots, 10000 \\] This framework allows for robust simulation of population data across multiple distribution types, fundamental for subsequent statistical analysis and inference. Sampling Process and Sampling Distribution of the Sample Mean Sampling from a population distribution is the core of inferential statistics. This process involves drawing samples of various sizes, calculating sample statistics, and understanding their behavior through repeated sampling. 1. Sampling from Population Distributions Given a population distribution with random variable \\(X\\) , we draw samples of size \\(n\\) : \\[ \\{X_1, X_2, \\ldots, X_n\\} \\quad \\text{i.i.d.} \\sim F_X \\] where \\(F_X\\) denotes the population distribution (e.g., Uniform, Exponential, Binomial). Typical sample sizes considered are: \\[ n \\in \\{5, 10, 30, 50\\} \\] 2. Sample Mean For each sample of size \\(n\\) , the sample mean \\(\\bar{X}_n\\) is calculated as: \\[ \\bar{X}_n = \\frac{1}{n} \\sum_{i=1}^n X_i \\] The sample mean \\(\\bar{X}_n\\) is a random variable itself because it depends on the randomly drawn sample. 3. Repeated Sampling and Sampling Distribution To understand the variability and distribution of the sample mean, repeat the sampling process \\(M\\) times: \\[ \\bar{X}_n^{(1)}, \\bar{X}_n^{(2)}, \\ldots, \\bar{X}_n^{(M)} \\] where each \\(\\bar{X}_n^{(j)}\\) is the mean of the \\(j\\) th sample of size \\(n\\) . This collection forms the sampling distribution of the sample mean for sample size \\(n\\) . 4. Properties of the Sampling Distribution By the Law of Large Numbers and Central Limit Theorem (CLT) , for sufficiently large \\(n\\) : The expected value of the sample mean equals the population mean \\(\\mu\\) : \\[ \\mathbb{E}[\\bar{X}_n] = \\mu \\] The variance of the sample mean is: \\[ \\mathrm{Var}(\\bar{X}_n) = \\frac{\\sigma^2}{n} \\] where \\(\\sigma^2\\) is the variance of the population. As \\(n \\to \\infty\\) , the distribution of \\(\\bar{X}_n\\) approaches a normal distribution: \\[ \\bar{X}_n \\xrightarrow{d} \\mathcal{N}\\left(\\mu, \\frac{\\sigma^2}{n}\\right) \\] 5. Practical Steps in the Sampling Process Randomly sample \\(n\\) observations from the population \\(X\\) . Calculate the sample mean \\(\\bar{X}_n\\) . Repeat steps 1 and 2, \\(M\\) times (e.g., \\(M = 1000\\) ). Construct the sampling distribution of \\(\\bar{X}_n\\) by collecting all sample means. This process allows us to empirically estimate the shape, mean, and variance of the sampling distribution. 6. Summary of Notation Symbol Meaning \\(X_i\\) \\(i\\) th observation from the population \\(n\\) Sample size \\(\\bar{X}_n\\) Sample mean for sample size \\(n\\) \\(M\\) Number of repeated samples (resamples) \\(\\mu\\) Population mean \\(\\sigma^2\\) Population variance Example: Sampling from a Uniform Population Assume \\[ X \\sim \\text{Uniform}(0,1) \\] For \\(n=5\\) : Draw \\(M=1000\\) samples \\(\\{X_1^{(j)}, \\ldots, X_5^{(j)}\\}\\) , \\(j=1,\\ldots,1000\\) . Compute \\[ \\bar{X}_5^{(j)} = \\frac{1}{5} \\sum_{i=1}^5 X_i^{(j)} \\] The empirical distribution of \\(\\{\\bar{X}_5^{(j)}\\}_{j=1}^{1000}\\) approximates the sampling distribution of \\(\\bar{X}_5\\) . Repeat the procedure for other sample sizes \\(n = 10, 30, 50\\) to observe the effect of increasing sample size on the sampling distribution. This framework sets the foundation for understanding estimator behavior and forms the basis of hypothesis testing and confidence interval construction in statistics. Practical Reflection on the Central Limit Theorem (CLT) The Central Limit Theorem (CLT) is a cornerstone of statistical inference, underpinning many real-world applications across diverse fields by justifying the approximation of sampling distributions as normal, regardless of the population distribution. 1. Real-World Applications of the CLT (a) Estimating Population Parameters The CLT allows practitioners to use sample means \\(\\bar{X}_n\\) to estimate population means \\(\\mu\\) with quantifiable uncertainty. Given a sufficiently large sample size \\(n\\) , the sampling distribution of \\(\\bar{X}_n\\) is approximately normal: \\[ \\bar{X}_n \\sim \\mathcal{N}\\left(\\mu, \\frac{\\sigma^2}{n}\\right) \\] This enables construction of confidence intervals and hypothesis tests for \\(\\mu\\) , even when the population distribution is unknown or non-normal. (b) Quality Control in Manufacturing In manufacturing processes, quality metrics (e.g., dimensions, weights) are monitored via sample means from production batches. The CLT justifies the use of control charts based on \\(\\bar{X}_n\\) to detect shifts in the process mean. The normality assumption allows setting control limits at: \\[ \\mu \\pm z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{n}} \\] where \\(z_{\\alpha/2}\\) is the critical value from the standard normal distribution. This helps identify defective batches and maintain product standards. (c) Predicting Outcomes in Financial Models Financial analysts rely on the CLT to model aggregate returns or portfolio averages. Even if individual asset returns are not normal, the average return of a large portfolio tends toward normality: \\[ \\bar{R}_n = \\frac{1}{n} \\sum_{i=1}^n R_i \\approx \\mathcal{N}\\left(\\mu_R, \\frac{\\sigma_R^2}{n}\\right) \\] This underpins risk management, option pricing, and value-at-risk calculations. 2. How Simulation Supports These Applications Through simulation, the theoretical properties of the CLT can be observed empirically: By generating repeated samples from various populations (e.g., skewed, discrete), and calculating sample means \\(\\bar{X}_n\\) , one observes that the distribution of \\(\\bar{X}_n\\) increasingly resembles a normal distribution as \\(n\\) grows. Simulations validate that variance of the sample mean decreases as \\(1/n\\) , confirming improved estimator precision. They demonstrate robustness of CLT applications, even when underlying assumptions are mildly violated. 3. Summary The CLT provides a powerful theoretical foundation enabling: Reliable parameter estimation from sample statistics. Quality assurance through monitoring sample means. Financial risk modeling using aggregate return distributions. Simulations act as practical tools to visualize and verify the CLT's guarantees, strengthening confidence in applying these statistical techniques to complex, real-world problems. Code and Plots import numpy as np import matplotlib.pyplot as plt import seaborn as sns from scipy.stats import norm # Set seaborn style sns.set(style=\"whitegrid\") # Parameters sample_sizes = [5, 10, 30, 50] num_repeats = 1000 # Population parameters uniform_params = (0, 1) # a=0, b=1 exp_lambda = 1.0 # lambda for exponential binom_n, binom_p = 10, 0.5 # Function to generate samples and calculate sample means def generate_sample_means(dist_name, sample_size, repeats): means = [] for _ in range(repeats): if dist_name == 'Uniform': sample = np.random.uniform(uniform_params[0], uniform_params[1], sample_size) elif dist_name == 'Exponential': sample = np.random.exponential(1/exp_lambda, sample_size) elif dist_name == 'Binomial': sample = np.random.binomial(binom_n, binom_p, sample_size) means.append(np.mean(sample)) return np.array(means) # Plot histograms fig, axes = plt.subplots(len(sample_sizes), 3, figsize=(15, 12), constrained_layout=True) dist_names = ['Uniform', 'Exponential', 'Binomial'] for row_idx, n in enumerate(sample_sizes): for col_idx, dist in enumerate(dist_names): sample_means = generate_sample_means(dist, n, num_repeats) ax = axes[row_idx, col_idx] sns.histplot(sample_means, bins=30, kde=True, color='skyblue', ax=ax, stat=\"density\") # Overlay Normal distribution fit mu, std = np.mean(sample_means), np.std(sample_means) x = np.linspace(mu - 4*std, mu + 4*std, 200) ax.plot(x, norm.pdf(x, mu, std), 'r--', lw=2, label='Normal fit') ax.set_title(f'{dist} Sample Means\\nn={n}, repeats={num_repeats}') ax.set_xlabel('Sample Mean') ax.set_ylabel('Density') ax.legend() plt.suptitle('Sampling Distribution of the Sample Mean\\nConvergence to Normal Distribution', fontsize=16, y=1.02) plt.show() Colab","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#data-generation-in-statistical-analysis","text":"Data generation is a foundational step in statistical modeling and simulation. Selecting appropriate population distribution types and generating large datasets representative of those populations is crucial for valid inference.","title":"Data Generation in Statistical Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_1/#population-distributions","text":"Consider three common types of population distributions:","title":"Population Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-uniform-distribution","text":"A continuous uniform distribution on the interval \\([a, b]\\) has the probability density function (PDF): \\[ f_X(x) = \\frac{1}{b - a}, \\quad a \\leq x \\leq b \\] The cumulative distribution function (CDF) is: \\[ F_X(x) = \\frac{x - a}{b - a}, \\quad a \\leq x \\leq b \\] To generate a dataset \\(\\{X_i\\}_{i=1}^n\\) from a uniform distribution, sample \\(n\\) independent observations where \\[ X_i \\sim \\text{Uniform}(a, b), \\quad i = 1, 2, \\ldots, n \\]","title":"1. Uniform Distribution"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-exponential-distribution","text":"The exponential distribution is often used to model waiting times and has PDF: \\[ f_X(x) = \\lambda e^{-\\lambda x}, \\quad x \\geq 0, \\lambda > 0 \\] where \\(\\lambda\\) is the rate parameter. The CDF is: \\[ F_X(x) = 1 - e^{-\\lambda x}, \\quad x \\geq 0 \\] Generate \\(n\\) samples from \\[ X_i \\sim \\text{Exponential}(\\lambda), \\quad i = 1, 2, \\ldots, n \\]","title":"2. Exponential Distribution"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-binomial-distribution","text":"The binomial distribution models the number of successes in \\(n\\) independent Bernoulli trials, each with success probability \\(p\\) . The probability mass function (PMF) is: \\[ P(X = k) = \\binom{n}{k} p^k (1-p)^{n-k}, \\quad k = 0, 1, \\ldots, n \\] To generate data, \\[ X_i \\sim \\text{Binomial}(n, p), \\quad i = 1, 2, \\ldots, m \\] where \\(m\\) is the number of generated observations.","title":"3. Binomial Distribution"},{"location":"1%20Physics/6%20Statistics/Problem_1/#generating-large-datasets","text":"Given a selected population distribution, generate a large dataset to approximate the population: Fix distribution parameters (e.g., \\(a,b\\) for uniform, \\(\\lambda\\) for exponential, \\(n,p\\) for binomial). Select a sample size \\(N\\) sufficiently large to represent the population well. Use random number generation methods to simulate: \\[ \\{X_i\\}_{i=1}^N \\sim \\text{Distribution}(\\text{parameters}) \\] This process provides a simulated population for analysis.","title":"Generating Large Datasets"},{"location":"1%20Physics/6%20Statistics/Problem_1/#summary","text":"Distribution Parameters Support PDF / PMF Uniform \\(a, b\\) \\([a,b]\\) \\(f_X(x) = \\frac{1}{b - a}\\) Exponential \\(\\lambda > 0\\) \\([0, \\infty)\\) \\(f_X(x) = \\lambda e^{-\\lambda x}\\) Binomial \\(n \\in \\mathbb{N}\\) , \\(p \\in [0,1]\\) \\(\\{0,\\ldots,n\\}\\) \\(P(X=k) = \\binom{n}{k} p^k (1-p)^{n-k}\\)","title":"Summary"},{"location":"1%20Physics/6%20Statistics/Problem_1/#example-generating-data","text":"Suppose we want to generate \\(N=10,000\\) samples from a uniform distribution on \\([0,1]\\) : \\[ X_i \\sim \\text{Uniform}(0,1), \\quad i=1,\\ldots, 10000 \\] Similarly, for exponential with \\(\\lambda=2\\) : \\[ X_i \\sim \\text{Exponential}(2), \\quad i=1,\\ldots, 10000 \\] And binomial with \\(n=10\\) , \\(p=0.5\\) : \\[ X_i \\sim \\text{Binomial}(10, 0.5), \\quad i=1,\\ldots, 10000 \\] This framework allows for robust simulation of population data across multiple distribution types, fundamental for subsequent statistical analysis and inference.","title":"Example: Generating Data"},{"location":"1%20Physics/6%20Statistics/Problem_1/#sampling-process-and-sampling-distribution-of-the-sample-mean","text":"Sampling from a population distribution is the core of inferential statistics. This process involves drawing samples of various sizes, calculating sample statistics, and understanding their behavior through repeated sampling.","title":"Sampling Process and Sampling Distribution of the Sample Mean"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-sampling-from-population-distributions","text":"Given a population distribution with random variable \\(X\\) , we draw samples of size \\(n\\) : \\[ \\{X_1, X_2, \\ldots, X_n\\} \\quad \\text{i.i.d.} \\sim F_X \\] where \\(F_X\\) denotes the population distribution (e.g., Uniform, Exponential, Binomial). Typical sample sizes considered are: \\[ n \\in \\{5, 10, 30, 50\\} \\]","title":"1. Sampling from Population Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-sample-mean","text":"For each sample of size \\(n\\) , the sample mean \\(\\bar{X}_n\\) is calculated as: \\[ \\bar{X}_n = \\frac{1}{n} \\sum_{i=1}^n X_i \\] The sample mean \\(\\bar{X}_n\\) is a random variable itself because it depends on the randomly drawn sample.","title":"2. Sample Mean"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-repeated-sampling-and-sampling-distribution","text":"To understand the variability and distribution of the sample mean, repeat the sampling process \\(M\\) times: \\[ \\bar{X}_n^{(1)}, \\bar{X}_n^{(2)}, \\ldots, \\bar{X}_n^{(M)} \\] where each \\(\\bar{X}_n^{(j)}\\) is the mean of the \\(j\\) th sample of size \\(n\\) . This collection forms the sampling distribution of the sample mean for sample size \\(n\\) .","title":"3. Repeated Sampling and Sampling Distribution"},{"location":"1%20Physics/6%20Statistics/Problem_1/#4-properties-of-the-sampling-distribution","text":"By the Law of Large Numbers and Central Limit Theorem (CLT) , for sufficiently large \\(n\\) : The expected value of the sample mean equals the population mean \\(\\mu\\) : \\[ \\mathbb{E}[\\bar{X}_n] = \\mu \\] The variance of the sample mean is: \\[ \\mathrm{Var}(\\bar{X}_n) = \\frac{\\sigma^2}{n} \\] where \\(\\sigma^2\\) is the variance of the population. As \\(n \\to \\infty\\) , the distribution of \\(\\bar{X}_n\\) approaches a normal distribution: \\[ \\bar{X}_n \\xrightarrow{d} \\mathcal{N}\\left(\\mu, \\frac{\\sigma^2}{n}\\right) \\]","title":"4. Properties of the Sampling Distribution"},{"location":"1%20Physics/6%20Statistics/Problem_1/#5-practical-steps-in-the-sampling-process","text":"Randomly sample \\(n\\) observations from the population \\(X\\) . Calculate the sample mean \\(\\bar{X}_n\\) . Repeat steps 1 and 2, \\(M\\) times (e.g., \\(M = 1000\\) ). Construct the sampling distribution of \\(\\bar{X}_n\\) by collecting all sample means. This process allows us to empirically estimate the shape, mean, and variance of the sampling distribution.","title":"5. Practical Steps in the Sampling Process"},{"location":"1%20Physics/6%20Statistics/Problem_1/#6-summary-of-notation","text":"Symbol Meaning \\(X_i\\) \\(i\\) th observation from the population \\(n\\) Sample size \\(\\bar{X}_n\\) Sample mean for sample size \\(n\\) \\(M\\) Number of repeated samples (resamples) \\(\\mu\\) Population mean \\(\\sigma^2\\) Population variance","title":"6. Summary of Notation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#example-sampling-from-a-uniform-population","text":"Assume \\[ X \\sim \\text{Uniform}(0,1) \\] For \\(n=5\\) : Draw \\(M=1000\\) samples \\(\\{X_1^{(j)}, \\ldots, X_5^{(j)}\\}\\) , \\(j=1,\\ldots,1000\\) . Compute \\[ \\bar{X}_5^{(j)} = \\frac{1}{5} \\sum_{i=1}^5 X_i^{(j)} \\] The empirical distribution of \\(\\{\\bar{X}_5^{(j)}\\}_{j=1}^{1000}\\) approximates the sampling distribution of \\(\\bar{X}_5\\) . Repeat the procedure for other sample sizes \\(n = 10, 30, 50\\) to observe the effect of increasing sample size on the sampling distribution.","title":"Example: Sampling from a Uniform Population"},{"location":"1%20Physics/6%20Statistics/Problem_1/#this-framework-sets-the-foundation-for-understanding-estimator-behavior-and-forms-the-basis-of-hypothesis-testing-and-confidence-interval-construction-in-statistics","text":"","title":"This framework sets the foundation for understanding estimator behavior and forms the basis of hypothesis testing and confidence interval construction in statistics."},{"location":"1%20Physics/6%20Statistics/Problem_1/#practical-reflection-on-the-central-limit-theorem-clt","text":"The Central Limit Theorem (CLT) is a cornerstone of statistical inference, underpinning many real-world applications across diverse fields by justifying the approximation of sampling distributions as normal, regardless of the population distribution.","title":"Practical Reflection on the Central Limit Theorem (CLT)"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-real-world-applications-of-the-clt","text":"","title":"1. Real-World Applications of the CLT"},{"location":"1%20Physics/6%20Statistics/Problem_1/#a-estimating-population-parameters","text":"The CLT allows practitioners to use sample means \\(\\bar{X}_n\\) to estimate population means \\(\\mu\\) with quantifiable uncertainty. Given a sufficiently large sample size \\(n\\) , the sampling distribution of \\(\\bar{X}_n\\) is approximately normal: \\[ \\bar{X}_n \\sim \\mathcal{N}\\left(\\mu, \\frac{\\sigma^2}{n}\\right) \\] This enables construction of confidence intervals and hypothesis tests for \\(\\mu\\) , even when the population distribution is unknown or non-normal.","title":"(a) Estimating Population Parameters"},{"location":"1%20Physics/6%20Statistics/Problem_1/#b-quality-control-in-manufacturing","text":"In manufacturing processes, quality metrics (e.g., dimensions, weights) are monitored via sample means from production batches. The CLT justifies the use of control charts based on \\(\\bar{X}_n\\) to detect shifts in the process mean. The normality assumption allows setting control limits at: \\[ \\mu \\pm z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{n}} \\] where \\(z_{\\alpha/2}\\) is the critical value from the standard normal distribution. This helps identify defective batches and maintain product standards.","title":"(b) Quality Control in Manufacturing"},{"location":"1%20Physics/6%20Statistics/Problem_1/#c-predicting-outcomes-in-financial-models","text":"Financial analysts rely on the CLT to model aggregate returns or portfolio averages. Even if individual asset returns are not normal, the average return of a large portfolio tends toward normality: \\[ \\bar{R}_n = \\frac{1}{n} \\sum_{i=1}^n R_i \\approx \\mathcal{N}\\left(\\mu_R, \\frac{\\sigma_R^2}{n}\\right) \\] This underpins risk management, option pricing, and value-at-risk calculations.","title":"(c) Predicting Outcomes in Financial Models"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-how-simulation-supports-these-applications","text":"Through simulation, the theoretical properties of the CLT can be observed empirically: By generating repeated samples from various populations (e.g., skewed, discrete), and calculating sample means \\(\\bar{X}_n\\) , one observes that the distribution of \\(\\bar{X}_n\\) increasingly resembles a normal distribution as \\(n\\) grows. Simulations validate that variance of the sample mean decreases as \\(1/n\\) , confirming improved estimator precision. They demonstrate robustness of CLT applications, even when underlying assumptions are mildly violated.","title":"2. How Simulation Supports These Applications"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-summary","text":"The CLT provides a powerful theoretical foundation enabling: Reliable parameter estimation from sample statistics. Quality assurance through monitoring sample means. Financial risk modeling using aggregate return distributions. Simulations act as practical tools to visualize and verify the CLT's guarantees, strengthening confidence in applying these statistical techniques to complex, real-world problems.","title":"3. Summary"},{"location":"1%20Physics/6%20Statistics/Problem_1/#code-and-plots","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns from scipy.stats import norm # Set seaborn style sns.set(style=\"whitegrid\") # Parameters sample_sizes = [5, 10, 30, 50] num_repeats = 1000 # Population parameters uniform_params = (0, 1) # a=0, b=1 exp_lambda = 1.0 # lambda for exponential binom_n, binom_p = 10, 0.5 # Function to generate samples and calculate sample means def generate_sample_means(dist_name, sample_size, repeats): means = [] for _ in range(repeats): if dist_name == 'Uniform': sample = np.random.uniform(uniform_params[0], uniform_params[1], sample_size) elif dist_name == 'Exponential': sample = np.random.exponential(1/exp_lambda, sample_size) elif dist_name == 'Binomial': sample = np.random.binomial(binom_n, binom_p, sample_size) means.append(np.mean(sample)) return np.array(means) # Plot histograms fig, axes = plt.subplots(len(sample_sizes), 3, figsize=(15, 12), constrained_layout=True) dist_names = ['Uniform', 'Exponential', 'Binomial'] for row_idx, n in enumerate(sample_sizes): for col_idx, dist in enumerate(dist_names): sample_means = generate_sample_means(dist, n, num_repeats) ax = axes[row_idx, col_idx] sns.histplot(sample_means, bins=30, kde=True, color='skyblue', ax=ax, stat=\"density\") # Overlay Normal distribution fit mu, std = np.mean(sample_means), np.std(sample_means) x = np.linspace(mu - 4*std, mu + 4*std, 200) ax.plot(x, norm.pdf(x, mu, std), 'r--', lw=2, label='Normal fit') ax.set_title(f'{dist} Sample Means\\nn={n}, repeats={num_repeats}') ax.set_xlabel('Sample Mean') ax.set_ylabel('Density') ax.legend() plt.suptitle('Sampling Distribution of the Sample Mean\\nConvergence to Normal Distribution', fontsize=16, y=1.02) plt.show() Colab","title":"Code and Plots"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 Circle-Based Method in Geometric Probability Overview The circle-based method for estimating \\(\\pi\\) leverages geometric probability . By randomly scattering points within a square that encloses a circle, one can approximate the value of \\(\\pi\\) based on the ratio of points that fall inside the circle to the total number of points. Estimating \\(\\pi\\) via the Unit Circle Consider a unit circle centered at the origin \\((0,0)\\) , inscribed within a square of side length \\(2\\) . The square has area: \\[ A_{\\text{square}} = (2)^2 = 4 \\] The area of the unit circle is: \\[ A_{\\text{circle}} = \\pi r^2 = \\pi(1)^2 = \\pi \\] Hence, the probability \\(P\\) that a point randomly chosen within the square lies inside the circle is: \\[ P = \\frac{A_{\\text{circle}}}{A_{\\text{square}}} = \\frac{\\pi}{4} \\] Thus, by randomly generating \\(N\\) points within the square, the fraction \\(f\\) of points falling inside the circle gives: \\[ f = \\frac{N_{\\text{in}}}{N} \\approx \\frac{\\pi}{4} \\Rightarrow \\pi \\approx 4f \\] This forms the basis for the Monte Carlo method of \\(\\pi\\) estimation. Alternative Geometric Formulations Quarter-Circle in First Quadrant Let us consider a quarter-circle of radius \\(1\\) in the first quadrant, inscribed in a unit square \\([0,1] \\times [0,1]\\) . The area of the quarter-circle is: \\[ A_{\\text{quarter-circle}} = \\frac{\\pi}{4} \\] Probability of a point falling within the quarter-circle is again: \\[ P = \\frac{\\pi/4}{1} = \\frac{\\pi}{4} \\] The formulation is equivalent, but this version reduces computation as all generated coordinates are in the positive quadrant. Generalization to Arbitrary Radius \\(r\\) If the circle has radius \\(r\\) and is inscribed in a square of side \\(2r\\) , then: \\[ \\frac{A_{\\text{circle}}}{A_{\\text{square}}} = \\frac{\\pi r^2}{(2r)^2} = \\frac{\\pi r^2}{4r^2} = \\frac{\\pi}{4} \\] The ratio remains independent of radius, reaffirming the robustness of the method under scaling. Impact of Non-Uniform Point Distributions The assumption underlying the method is that points are uniformly distributed over the square. Let \\(p(x, y)\\) be the probability density function (PDF) of the point distribution. If \\(p(x, y) \\neq \\text{const.}\\) , then: \\[ P = \\iint_{(x,y) \\in \\text{circle}} p(x,y) \\, dx \\, dy \\] The empirical ratio no longer represents \\(\\pi/4\\) , and estimation becomes biased. Example: Radial Bias Let points be sampled with a radial bias towards the center: \\[ p(x,y) \\propto \\exp\\left(-\\alpha (x^2 + y^2)\\right) \\] The integral over the circular region increases relative to the uniform case, leading to overestimation of \\(\\pi\\) . Statistical Error and Variance Let \\(X_i\\) be an indicator random variable: \\[ X_i = \\begin{cases} 1 & \\text{if point $i$ is inside the circle} \\\\ 0 & \\text{otherwise} \\end{cases} \\] Then: Expected value: \\(\\mathbb{E}[X_i] = \\frac{\\pi}{4}\\) Variance: \\(\\text{Var}(X_i) = \\frac{\\pi}{4} \\left(1 - \\frac{\\pi}{4} \\right)\\) Let \\(\\hat{\\pi}_N = 4 \\cdot \\frac{1}{N} \\sum_{i=1}^{N} X_i\\) , then by Central Limit Theorem : \\[ \\hat{\\pi}_N \\sim \\mathcal{N} \\left( \\pi, \\frac{16}{N} \\cdot \\frac{\\pi}{4} \\left(1 - \\frac{\\pi}{4} \\right) \\right) \\] Thus, the standard error of the estimate is: \\[ \\text{SE}(\\hat{\\pi}_N) = \\sqrt{ \\frac{16}{N} \\cdot \\frac{\\pi}{4} \\left(1 - \\frac{\\pi}{4} \\right) } \\] Conclusion The circle-based method is a beautiful application of geometric probability. While simple and intuitive, its accuracy hinges on uniform sampling and grows slowly with \\(N\\) due to statistical variance. Exploring alternative geometries and correcting for distributional biases remain rich avenues for refinement. Buffon\u2019s Needle Method in Geometric Probability Classical Setup Buffon's Needle is a classical problem in geometric probability , originally devised to estimate \\(\\pi\\) . It involves dropping a needle of length \\(\\ell\\) onto a floor ruled with parallel lines spaced a distance \\(d\\) apart \\((\\ell \\leq d)\\) . Let \\(\\theta\\) be the acute angle between the needle and the lines ( \\(\\theta \\in [0, \\frac{\\pi}{2}]\\) ), and let \\(x\\) be the perpendicular distance from the needle's center to the nearest line ( \\(x \\in [0, \\frac{d}{2}]\\) ). The needle crosses a line if: \\[ x \\leq \\frac{\\ell}{2} \\sin \\theta \\] Integrating over all valid \\((x, \\theta)\\) pairs, the probability of a crossing is: \\[ P = \\frac{2\\ell}{\\pi d} \\] Thus, the estimate for \\(\\pi\\) becomes: \\[ \\pi \\approx \\frac{2\\ell N}{d N_{\\text{cross}}} \\] where \\(N\\) is the total number of drops, and \\(N_{\\text{cross}}\\) is the number of crossings. Generalization: Variable Needle Length When \\(\\ell > d\\) , the geometry must accommodate needles longer than the line spacing. The probability of crossing becomes piecewise: \\[ P = \\begin{cases} \\frac{2\\ell}{\\pi d} & \\text{if } \\ell \\leq d \\\\ \\frac{2}{\\pi} \\left[ \\frac{\\ell}{d} - \\sqrt{1 - \\left(\\frac{d}{\\ell} \\right)^2} + \\arccos\\left( \\frac{d}{\\ell} \\right) \\right] & \\text{if } \\ell > d \\end{cases} \\] This more complex expression reflects how longer needles nearly always intersect a line unless they fall nearly parallel to the lines. Alternative Configurations 1. Non-Uniform Line Spacing Suppose the spacing varies periodically or randomly: \\(d = d(x)\\) . Then: \\[ P = \\mathbb{E}_{x,\\theta} \\left[ \\mathbb{I} \\left( x \\leq \\frac{\\ell}{2} \\sin \\theta \\right) \\cdot p_d(x) \\right] \\] where \\(p_d(x)\\) is the probability density of line spacing at \\(x\\) . 2. Non-Parallel or Grid Patterns For grid lines (vertical and horizontal): A crossing occurs if the needle intersects either set of lines. Let \\(P_v\\) and \\(P_h\\) be probabilities of vertical and horizontal line crossings, then: \\[ P_{\\text{grid}} = P_v + P_h - P_v P_h \\] Each can be evaluated independently using Buffon's formula, as orientation affects projections along both axes. 3. Curved or Finite-Length Lines If the lines are curved (e.g., concentric arcs) or of finite length , one must numerically integrate over local tangent angles and spatial inhomogeneities. Let \\(\\gamma(s)\\) be a family of curve parameterizations, then crossing probability involves: \\[ P = \\iint_{\\text{needle domain}} \\mathbb{I}(\\text{intersect}(\\gamma(s), \\text{needle})) \\, d\\theta \\, dx \\] Non-Ideal Needles 1. Needle Thickness If needle has radius \\(r > 0\\) , the crossing condition becomes more generous: \\[ x \\leq \\frac{\\ell}{2} \\sin \\theta + r \\] This inflates the crossing probability and must be corrected for accurate \\(\\pi\\) estimation. 2. Curved Needles For a circular arc of angle \\(\\phi\\) and radius \\(R\\) : Arc length: \\(\\ell = R \\phi\\) Projection geometry changes, requiring simulation or advanced integral geometry to evaluate \\(P(\\text{cross})\\) . Convergence Analysis Buffon vs. Circle-Based Method Let \\(X_i\\) be the crossing indicator ( \\(1\\) if intersects, \\(0\\) otherwise), then: Mean: \\(\\mathbb{E}[X_i] = P\\) Variance: \\(\\text{Var}(X_i) = P(1 - P)\\) Let \\(\\hat{\\pi}_N\\) be the estimate of \\(\\pi\\) using \\(N\\) trials. Buffon\u2019s Method: \\[ \\hat{\\pi}_N = \\frac{2\\ell N}{d N_{\\text{cross}}} \\] Using the delta method for variance: \\[ \\text{Var}(\\hat{\\pi}_N) \\approx \\left( \\frac{\\partial \\hat{\\pi}}{\\partial N_{\\text{cross}}} \\right)^2 \\text{Var}(N_{\\text{cross}}) = \\left( \\frac{-2\\ell N}{d N_{\\text{cross}}^2} \\right)^2 \\cdot N P(1 - P) \\] Thus, variance decays as \\(1/N\\) , but has a larger constant than in the circle-based method due to greater sensitivity to rare events (low \\(P\\) when \\(\\ell \\ll d\\) ). Circle-Based Method: More robust to distributional noise Generally exhibits lower variance for same \\(N\\) , especially when using uniformly random \\((x, y)\\) coordinates Summary of Comparison Feature Buffon\u2019s Needle Circle-Based Method Variance Higher (especially for short \\(\\ell\\) ) Lower Implementation Simple with ruler Easier with random \\((x, y)\\) Extensions Rich geometric possibilities Limited to planar ratios Bias Potential Sensitive to misalignment or curvature Sensitive to non-uniformity Conclusion Buffon\u2019s Needle provides a profound historical example of geometric probability and \\(\\pi\\) estimation. While elegant, its practical use requires careful handling of geometry and error sources. Modern analyses generalize Buffon\u2019s setup to a rich landscape of probabilistic geometry, offering fertile ground for research and simulation. General Theoretical Enhancements in Monte Carlo \u03c0 Estimation 1. Broader Context: Monte Carlo Methods Across Disciplines Both the Circle-Based and Buffon\u2019s Needle methods are instances of Monte Carlo integration , where we estimate a quantity by averaging the outcomes of random samples. These techniques form the basis for methods used in: Physics : Path integrals in quantum mechanics, Ising models in statistical mechanics. Finance : Option pricing via stochastic differential equations (e.g., Black-Scholes). Engineering : Uncertainty quantification and robust design under probabilistic constraints. The general form of Monte Carlo estimation is: \\[ \\mathbb{E}[f(X)] \\approx \\frac{1}{N} \\sum_{i=1}^{N} f(X_i) \\] where \\(X_i\\) are i.i.d. samples from a distribution and \\(f\\) is a measurable function. In both \u03c0 estimation methods, \\(f(X_i)\\) is an indicator function for a geometric event (e.g., being inside a circle or crossing a line). 2. Unified Framework: Geometric Probability and \u03c0 Estimation Let \\(\\Omega\\) be a sample space of spatial configurations, with probability measure \\(\\mathbb{P}\\) defined over it. Define a geometric event \\(A\\) such that: \\[ \\mathbb{P}(A) = \\frac{\\pi}{4} \\] for the circle method, or \\(= \\frac{2\\ell}{\\pi d}\\) in Buffon\u2019s method. Then define the random variable: \\[ Z_i = \\mathbb{I}_{A}(X_i) \\] and Monte Carlo estimation becomes: \\[ \\hat{p} = \\frac{1}{N} \\sum_{i=1}^{N} Z_i \\Rightarrow \\pi \\approx \\mathcal{T}(\\hat{p}) \\] where \\(\\mathcal{T}\\) is a transformation function mapping the estimated probability back to an estimate of \\(\\pi\\) . For instance: Circle Method: \\(\\mathcal{T}(p) = 4p\\) Buffon Method: \\(\\mathcal{T}(p) = \\frac{2\\ell}{d p}\\) Thus, both methods become specific instances of a general pipeline: Define spatial probability space Sample \\(X_i\\) Evaluate indicator \\(Z_i\\) Transform via \\(\\mathcal{T}\\) to estimate \\(\\pi\\) 3. Computational Precision and Numerical Stability Monte Carlo methods are sensitive to floating-point errors , especially when working with large \\(N\\) or small probabilities. Issues: Finite-precision arithmetic introduces round-off error in trigonometric and square-root operations. Catastrophic cancellation occurs when subtracting nearly equal numbers (e.g., \\(\\sqrt{1 - \\epsilon}\\) ). The law of large numbers converges slowly if error is not controlled. Model for Floating-Point Error Impact: Let \\(\\hat{\\pi}_{\\text{true}}\\) be the ideal estimate and \\(\\hat{\\pi}_{\\text{float}}\\) be the computed one. Then: \\[ \\hat{\\pi}_{\\text{float}} = \\hat{\\pi}_{\\text{true}} + \\epsilon_{\\text{rand}} + \\epsilon_{\\text{fp}} \\] where: - \\(\\epsilon_{\\text{rand}}\\) is sampling error ( \\(\\sim \\mathcal{O}(1/\\sqrt{N})\\) ) - \\(\\epsilon_{\\text{fp}}\\) is computational error ( \\(\\sim \\mathcal{O}(\\varepsilon_{\\text{machine}})\\) ) For IEEE-754 double precision, \\(\\varepsilon_{\\text{machine}} \\approx 2^{-53} \\approx 1.1 \\times 10^{-16}\\) 4. Bayesian Refinement of \u03c0 Estimates Rather than using a point estimate, we may adopt a Bayesian inference approach to model uncertainty in \\(\\pi\\) . Let \\(Z_i \\sim \\text{Bernoulli}(p)\\) with prior on \\(p\\) given by: \\[ p \\sim \\text{Beta}(\\alpha, \\beta) \\] The posterior is then: \\[ p \\mid Z_1, \\dots, Z_N \\sim \\text{Beta}(\\alpha + S, \\beta + N - S) \\] where \\(S = \\sum Z_i\\) is the number of successes (circle hits or needle crossings). Estimate of \\(\\pi\\) becomes a posterior mean : Circle Method: $$ \\mathbb{E}[\\pi \\mid \\text{data}] = 4 \\cdot \\frac{\\alpha + S}{\\alpha + \\beta + N} $$ Buffon\u2019s Method: $$ \\mathbb{E}[\\pi \\mid \\text{data}] = \\frac{2\\ell}{d} \\cdot \\frac{\\alpha + \\beta + N}{\\alpha + S} $$ Advantages: Produces credible intervals rather than just point estimates Handles small \\(N\\) robustly Can incorporate prior knowledge (e.g., we believe \\(\\pi \\in (3, 3.2)\\) ) Summary Table Enhancement Type Description Implications Cross-Domain Monte Carlo Connection to physics, finance Deepens understanding, extends utility Unified Framework Indicator-based probability estimation Allows comparative analysis of methods Floating-Point Model Error decomposition into sampling and machine error Guides implementation-level accuracy Bayesian Refinement Beta-binomial model for posterior \\(\\pi\\) Offers uncertainty quantification Conclusion By embedding Circle-Based and Buffon\u2019s Needle methods into the broader landscape of probabilistic modeling, we reveal deep connections to other domains and improve practical implementation. Bayesian and numerical models offer robust tools to quantify and reduce uncertainty \u2014 turning classical thought experiments into modern statistical machinery. Code and Plots import numpy as np import matplotlib.pyplot as plt # Set number of random points N = 10000 # Generate random points in [-1, 1] x [-1, 1] x = np.random.uniform(-1, 1, N) y = np.random.uniform(-1, 1, N) # Compute distances from origin dist_sq = x**2 + y**2 inside = dist_sq <= 1 # Estimate \u03c0 pi_estimate = 4 * np.sum(inside) / N print(f\"Estimated \u03c0 with {N} points: {pi_estimate:.6f}\") # Plotting fig, ax = plt.subplots(figsize=(6, 6), dpi=120) # Plot points ax.scatter(x[inside], y[inside], color='blue', s=1, label='Inside Circle') ax.scatter(x[~inside], y[~inside], color='red', s=1, label='Outside Circle') # Circle boundary circle = plt.Circle((0, 0), 1, edgecolor='black', facecolor='none', linewidth=2) ax.add_patch(circle) # Square boundary ax.set_xlim(-1, 1) ax.set_ylim(-1, 1) ax.set_aspect('equal') ax.set_title(f\"Monte Carlo Estimation of \u03c0\\nEstimated \u03c0 \u2248 {pi_estimate:.6f}\") ax.legend(loc='lower left', markerscale=6, frameon=True) # Remove axes for clean appearance ax.axis('off') # Save high-resolution image (optional) # plt.savefig(\"monte_carlo_pi_estimate.png\", dpi=300, bbox_inches='tight') plt.show() import numpy as np import matplotlib.pyplot as plt # Parameters needle_length = 1.0 line_spacing = 2.0 num_needles = 100_000 # Large number for accuracy # Generate random needle centers and angles x_centers = np.random.uniform(0, 4 * line_spacing, num_needles) theta = np.random.uniform(0, np.pi, num_needles) # Calculate needle endpoints dx = (needle_length / 2) * np.cos(theta) x1 = x_centers - dx x2 = x_centers + dx # Robust crossing check function def check_crossings(x1, x2, line_spacing, max_x): lines = np.arange(0, max_x + line_spacing, line_spacing) crosses = np.zeros(x1.shape, dtype=bool) for line_x in lines: cond = (x1 - line_x) * (x2 - line_x) <= 0 cond &= (x1 != x2) # Exclude needles that just touch at an endpoint crosses = crosses | cond return crosses max_x = 4 * line_spacing crosses = check_crossings(x1, x2, line_spacing, max_x) num_crosses = np.sum(crosses) # Pi estimation formula pi_estimate = (2 * needle_length * num_needles) / (line_spacing * num_crosses) # Calculate standard error p_hat = num_crosses / num_needles variance = p_hat * (1 - p_hat) se_pi = (2 * needle_length) / (line_spacing * p_hat**2) * np.sqrt(variance / num_needles) print(f\"Estimated \u03c0 = {pi_estimate:.8f}\") print(f\"Standard error = \u00b1{se_pi:.8f}\") # Visualization: sample 50 needles for clarity sample_indices = np.random.choice(num_needles, 50, replace=False) x1_vis = x1[sample_indices] x2_vis = x2[sample_indices] crosses_vis = crosses[sample_indices] y_vis = np.linspace(0, 50, 50) # Plotting fig, ax = plt.subplots(figsize=(12, 6)) # Draw vertical lines for i in range(5): ax.axvline(i * line_spacing, color='black', linestyle='--', linewidth=1) # Draw needles, color-coded by crossing for i in range(50): color = 'blue' if crosses_vis[i] else 'red' ax.plot([x1_vis[i], x2_vis[i]], [y_vis[i], y_vis[i]], color=color, linewidth=2) ax.scatter([x1_vis[i], x2_vis[i]], [y_vis[i], y_vis[i]], color=color, s=20) ax.set_xlim(-1, max_x + 1) ax.set_ylim(-5, 55) ax.set_yticks([]) ax.set_title(f\"Buffon\u2019s Needle Simulation (n={num_needles})\\nEstimated \u03c0 = {pi_estimate:.8f} \u00b1 {se_pi:.8f}\", fontsize=16) ax.set_xlabel(\"Horizontal position\") plt.tight_layout() plt.show() Colab","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#circle-based-method-in-geometric-probability","text":"","title":"Circle-Based Method in Geometric Probability"},{"location":"1%20Physics/6%20Statistics/Problem_2/#overview","text":"The circle-based method for estimating \\(\\pi\\) leverages geometric probability . By randomly scattering points within a square that encloses a circle, one can approximate the value of \\(\\pi\\) based on the ratio of points that fall inside the circle to the total number of points.","title":"Overview"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-pi-via-the-unit-circle","text":"Consider a unit circle centered at the origin \\((0,0)\\) , inscribed within a square of side length \\(2\\) . The square has area: \\[ A_{\\text{square}} = (2)^2 = 4 \\] The area of the unit circle is: \\[ A_{\\text{circle}} = \\pi r^2 = \\pi(1)^2 = \\pi \\] Hence, the probability \\(P\\) that a point randomly chosen within the square lies inside the circle is: \\[ P = \\frac{A_{\\text{circle}}}{A_{\\text{square}}} = \\frac{\\pi}{4} \\] Thus, by randomly generating \\(N\\) points within the square, the fraction \\(f\\) of points falling inside the circle gives: \\[ f = \\frac{N_{\\text{in}}}{N} \\approx \\frac{\\pi}{4} \\Rightarrow \\pi \\approx 4f \\] This forms the basis for the Monte Carlo method of \\(\\pi\\) estimation.","title":"Estimating \\(\\pi\\) via the Unit Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#alternative-geometric-formulations","text":"","title":"Alternative Geometric Formulations"},{"location":"1%20Physics/6%20Statistics/Problem_2/#quarter-circle-in-first-quadrant","text":"Let us consider a quarter-circle of radius \\(1\\) in the first quadrant, inscribed in a unit square \\([0,1] \\times [0,1]\\) . The area of the quarter-circle is: \\[ A_{\\text{quarter-circle}} = \\frac{\\pi}{4} \\] Probability of a point falling within the quarter-circle is again: \\[ P = \\frac{\\pi/4}{1} = \\frac{\\pi}{4} \\] The formulation is equivalent, but this version reduces computation as all generated coordinates are in the positive quadrant.","title":"Quarter-Circle in First Quadrant"},{"location":"1%20Physics/6%20Statistics/Problem_2/#generalization-to-arbitrary-radius-r","text":"If the circle has radius \\(r\\) and is inscribed in a square of side \\(2r\\) , then: \\[ \\frac{A_{\\text{circle}}}{A_{\\text{square}}} = \\frac{\\pi r^2}{(2r)^2} = \\frac{\\pi r^2}{4r^2} = \\frac{\\pi}{4} \\] The ratio remains independent of radius, reaffirming the robustness of the method under scaling.","title":"Generalization to Arbitrary Radius \\(r\\)"},{"location":"1%20Physics/6%20Statistics/Problem_2/#impact-of-non-uniform-point-distributions","text":"The assumption underlying the method is that points are uniformly distributed over the square. Let \\(p(x, y)\\) be the probability density function (PDF) of the point distribution. If \\(p(x, y) \\neq \\text{const.}\\) , then: \\[ P = \\iint_{(x,y) \\in \\text{circle}} p(x,y) \\, dx \\, dy \\] The empirical ratio no longer represents \\(\\pi/4\\) , and estimation becomes biased.","title":"Impact of Non-Uniform Point Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_2/#example-radial-bias","text":"Let points be sampled with a radial bias towards the center: \\[ p(x,y) \\propto \\exp\\left(-\\alpha (x^2 + y^2)\\right) \\] The integral over the circular region increases relative to the uniform case, leading to overestimation of \\(\\pi\\) .","title":"Example: Radial Bias"},{"location":"1%20Physics/6%20Statistics/Problem_2/#statistical-error-and-variance","text":"Let \\(X_i\\) be an indicator random variable: \\[ X_i = \\begin{cases} 1 & \\text{if point $i$ is inside the circle} \\\\ 0 & \\text{otherwise} \\end{cases} \\] Then: Expected value: \\(\\mathbb{E}[X_i] = \\frac{\\pi}{4}\\) Variance: \\(\\text{Var}(X_i) = \\frac{\\pi}{4} \\left(1 - \\frac{\\pi}{4} \\right)\\) Let \\(\\hat{\\pi}_N = 4 \\cdot \\frac{1}{N} \\sum_{i=1}^{N} X_i\\) , then by Central Limit Theorem : \\[ \\hat{\\pi}_N \\sim \\mathcal{N} \\left( \\pi, \\frac{16}{N} \\cdot \\frac{\\pi}{4} \\left(1 - \\frac{\\pi}{4} \\right) \\right) \\] Thus, the standard error of the estimate is: \\[ \\text{SE}(\\hat{\\pi}_N) = \\sqrt{ \\frac{16}{N} \\cdot \\frac{\\pi}{4} \\left(1 - \\frac{\\pi}{4} \\right) } \\]","title":"Statistical Error and Variance"},{"location":"1%20Physics/6%20Statistics/Problem_2/#conclusion","text":"The circle-based method is a beautiful application of geometric probability. While simple and intuitive, its accuracy hinges on uniform sampling and grows slowly with \\(N\\) due to statistical variance. Exploring alternative geometries and correcting for distributional biases remain rich avenues for refinement.","title":"Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_2/#buffons-needle-method-in-geometric-probability","text":"","title":"Buffon\u2019s Needle Method in Geometric Probability"},{"location":"1%20Physics/6%20Statistics/Problem_2/#classical-setup","text":"Buffon's Needle is a classical problem in geometric probability , originally devised to estimate \\(\\pi\\) . It involves dropping a needle of length \\(\\ell\\) onto a floor ruled with parallel lines spaced a distance \\(d\\) apart \\((\\ell \\leq d)\\) . Let \\(\\theta\\) be the acute angle between the needle and the lines ( \\(\\theta \\in [0, \\frac{\\pi}{2}]\\) ), and let \\(x\\) be the perpendicular distance from the needle's center to the nearest line ( \\(x \\in [0, \\frac{d}{2}]\\) ). The needle crosses a line if: \\[ x \\leq \\frac{\\ell}{2} \\sin \\theta \\] Integrating over all valid \\((x, \\theta)\\) pairs, the probability of a crossing is: \\[ P = \\frac{2\\ell}{\\pi d} \\] Thus, the estimate for \\(\\pi\\) becomes: \\[ \\pi \\approx \\frac{2\\ell N}{d N_{\\text{cross}}} \\] where \\(N\\) is the total number of drops, and \\(N_{\\text{cross}}\\) is the number of crossings.","title":"Classical Setup"},{"location":"1%20Physics/6%20Statistics/Problem_2/#generalization-variable-needle-length","text":"When \\(\\ell > d\\) , the geometry must accommodate needles longer than the line spacing. The probability of crossing becomes piecewise: \\[ P = \\begin{cases} \\frac{2\\ell}{\\pi d} & \\text{if } \\ell \\leq d \\\\ \\frac{2}{\\pi} \\left[ \\frac{\\ell}{d} - \\sqrt{1 - \\left(\\frac{d}{\\ell} \\right)^2} + \\arccos\\left( \\frac{d}{\\ell} \\right) \\right] & \\text{if } \\ell > d \\end{cases} \\] This more complex expression reflects how longer needles nearly always intersect a line unless they fall nearly parallel to the lines.","title":"Generalization: Variable Needle Length"},{"location":"1%20Physics/6%20Statistics/Problem_2/#alternative-configurations","text":"","title":"Alternative Configurations"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-non-uniform-line-spacing","text":"Suppose the spacing varies periodically or randomly: \\(d = d(x)\\) . Then: \\[ P = \\mathbb{E}_{x,\\theta} \\left[ \\mathbb{I} \\left( x \\leq \\frac{\\ell}{2} \\sin \\theta \\right) \\cdot p_d(x) \\right] \\] where \\(p_d(x)\\) is the probability density of line spacing at \\(x\\) .","title":"1. Non-Uniform Line Spacing"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-non-parallel-or-grid-patterns","text":"For grid lines (vertical and horizontal): A crossing occurs if the needle intersects either set of lines. Let \\(P_v\\) and \\(P_h\\) be probabilities of vertical and horizontal line crossings, then: \\[ P_{\\text{grid}} = P_v + P_h - P_v P_h \\] Each can be evaluated independently using Buffon's formula, as orientation affects projections along both axes.","title":"2. Non-Parallel or Grid Patterns"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-curved-or-finite-length-lines","text":"If the lines are curved (e.g., concentric arcs) or of finite length , one must numerically integrate over local tangent angles and spatial inhomogeneities. Let \\(\\gamma(s)\\) be a family of curve parameterizations, then crossing probability involves: \\[ P = \\iint_{\\text{needle domain}} \\mathbb{I}(\\text{intersect}(\\gamma(s), \\text{needle})) \\, d\\theta \\, dx \\]","title":"3. Curved or Finite-Length Lines"},{"location":"1%20Physics/6%20Statistics/Problem_2/#non-ideal-needles","text":"","title":"Non-Ideal Needles"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-needle-thickness","text":"If needle has radius \\(r > 0\\) , the crossing condition becomes more generous: \\[ x \\leq \\frac{\\ell}{2} \\sin \\theta + r \\] This inflates the crossing probability and must be corrected for accurate \\(\\pi\\) estimation.","title":"1. Needle Thickness"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-curved-needles","text":"For a circular arc of angle \\(\\phi\\) and radius \\(R\\) : Arc length: \\(\\ell = R \\phi\\) Projection geometry changes, requiring simulation or advanced integral geometry to evaluate \\(P(\\text{cross})\\) .","title":"2. Curved Needles"},{"location":"1%20Physics/6%20Statistics/Problem_2/#convergence-analysis","text":"","title":"Convergence Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#buffon-vs-circle-based-method","text":"Let \\(X_i\\) be the crossing indicator ( \\(1\\) if intersects, \\(0\\) otherwise), then: Mean: \\(\\mathbb{E}[X_i] = P\\) Variance: \\(\\text{Var}(X_i) = P(1 - P)\\) Let \\(\\hat{\\pi}_N\\) be the estimate of \\(\\pi\\) using \\(N\\) trials.","title":"Buffon vs. Circle-Based Method"},{"location":"1%20Physics/6%20Statistics/Problem_2/#buffons-method","text":"\\[ \\hat{\\pi}_N = \\frac{2\\ell N}{d N_{\\text{cross}}} \\] Using the delta method for variance: \\[ \\text{Var}(\\hat{\\pi}_N) \\approx \\left( \\frac{\\partial \\hat{\\pi}}{\\partial N_{\\text{cross}}} \\right)^2 \\text{Var}(N_{\\text{cross}}) = \\left( \\frac{-2\\ell N}{d N_{\\text{cross}}^2} \\right)^2 \\cdot N P(1 - P) \\] Thus, variance decays as \\(1/N\\) , but has a larger constant than in the circle-based method due to greater sensitivity to rare events (low \\(P\\) when \\(\\ell \\ll d\\) ).","title":"Buffon\u2019s Method:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#circle-based-method","text":"More robust to distributional noise Generally exhibits lower variance for same \\(N\\) , especially when using uniformly random \\((x, y)\\) coordinates","title":"Circle-Based Method:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#summary-of-comparison","text":"Feature Buffon\u2019s Needle Circle-Based Method Variance Higher (especially for short \\(\\ell\\) ) Lower Implementation Simple with ruler Easier with random \\((x, y)\\) Extensions Rich geometric possibilities Limited to planar ratios Bias Potential Sensitive to misalignment or curvature Sensitive to non-uniformity","title":"Summary of Comparison"},{"location":"1%20Physics/6%20Statistics/Problem_2/#conclusion_1","text":"Buffon\u2019s Needle provides a profound historical example of geometric probability and \\(\\pi\\) estimation. While elegant, its practical use requires careful handling of geometry and error sources. Modern analyses generalize Buffon\u2019s setup to a rich landscape of probabilistic geometry, offering fertile ground for research and simulation.","title":"Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_2/#general-theoretical-enhancements-in-monte-carlo-estimation","text":"","title":"General Theoretical Enhancements in Monte Carlo \u03c0 Estimation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-broader-context-monte-carlo-methods-across-disciplines","text":"Both the Circle-Based and Buffon\u2019s Needle methods are instances of Monte Carlo integration , where we estimate a quantity by averaging the outcomes of random samples. These techniques form the basis for methods used in: Physics : Path integrals in quantum mechanics, Ising models in statistical mechanics. Finance : Option pricing via stochastic differential equations (e.g., Black-Scholes). Engineering : Uncertainty quantification and robust design under probabilistic constraints. The general form of Monte Carlo estimation is: \\[ \\mathbb{E}[f(X)] \\approx \\frac{1}{N} \\sum_{i=1}^{N} f(X_i) \\] where \\(X_i\\) are i.i.d. samples from a distribution and \\(f\\) is a measurable function. In both \u03c0 estimation methods, \\(f(X_i)\\) is an indicator function for a geometric event (e.g., being inside a circle or crossing a line).","title":"1. Broader Context: Monte Carlo Methods Across Disciplines"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-unified-framework-geometric-probability-and-estimation","text":"Let \\(\\Omega\\) be a sample space of spatial configurations, with probability measure \\(\\mathbb{P}\\) defined over it. Define a geometric event \\(A\\) such that: \\[ \\mathbb{P}(A) = \\frac{\\pi}{4} \\] for the circle method, or \\(= \\frac{2\\ell}{\\pi d}\\) in Buffon\u2019s method. Then define the random variable: \\[ Z_i = \\mathbb{I}_{A}(X_i) \\] and Monte Carlo estimation becomes: \\[ \\hat{p} = \\frac{1}{N} \\sum_{i=1}^{N} Z_i \\Rightarrow \\pi \\approx \\mathcal{T}(\\hat{p}) \\] where \\(\\mathcal{T}\\) is a transformation function mapping the estimated probability back to an estimate of \\(\\pi\\) . For instance: Circle Method: \\(\\mathcal{T}(p) = 4p\\) Buffon Method: \\(\\mathcal{T}(p) = \\frac{2\\ell}{d p}\\) Thus, both methods become specific instances of a general pipeline: Define spatial probability space Sample \\(X_i\\) Evaluate indicator \\(Z_i\\) Transform via \\(\\mathcal{T}\\) to estimate \\(\\pi\\)","title":"2. Unified Framework: Geometric Probability and \u03c0 Estimation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-computational-precision-and-numerical-stability","text":"Monte Carlo methods are sensitive to floating-point errors , especially when working with large \\(N\\) or small probabilities.","title":"3. Computational Precision and Numerical Stability"},{"location":"1%20Physics/6%20Statistics/Problem_2/#issues","text":"Finite-precision arithmetic introduces round-off error in trigonometric and square-root operations. Catastrophic cancellation occurs when subtracting nearly equal numbers (e.g., \\(\\sqrt{1 - \\epsilon}\\) ). The law of large numbers converges slowly if error is not controlled.","title":"Issues:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#model-for-floating-point-error-impact","text":"Let \\(\\hat{\\pi}_{\\text{true}}\\) be the ideal estimate and \\(\\hat{\\pi}_{\\text{float}}\\) be the computed one. Then: \\[ \\hat{\\pi}_{\\text{float}} = \\hat{\\pi}_{\\text{true}} + \\epsilon_{\\text{rand}} + \\epsilon_{\\text{fp}} \\] where: - \\(\\epsilon_{\\text{rand}}\\) is sampling error ( \\(\\sim \\mathcal{O}(1/\\sqrt{N})\\) ) - \\(\\epsilon_{\\text{fp}}\\) is computational error ( \\(\\sim \\mathcal{O}(\\varepsilon_{\\text{machine}})\\) ) For IEEE-754 double precision, \\(\\varepsilon_{\\text{machine}} \\approx 2^{-53} \\approx 1.1 \\times 10^{-16}\\)","title":"Model for Floating-Point Error Impact:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-bayesian-refinement-of-estimates","text":"Rather than using a point estimate, we may adopt a Bayesian inference approach to model uncertainty in \\(\\pi\\) . Let \\(Z_i \\sim \\text{Bernoulli}(p)\\) with prior on \\(p\\) given by: \\[ p \\sim \\text{Beta}(\\alpha, \\beta) \\] The posterior is then: \\[ p \\mid Z_1, \\dots, Z_N \\sim \\text{Beta}(\\alpha + S, \\beta + N - S) \\] where \\(S = \\sum Z_i\\) is the number of successes (circle hits or needle crossings). Estimate of \\(\\pi\\) becomes a posterior mean : Circle Method: $$ \\mathbb{E}[\\pi \\mid \\text{data}] = 4 \\cdot \\frac{\\alpha + S}{\\alpha + \\beta + N} $$ Buffon\u2019s Method: $$ \\mathbb{E}[\\pi \\mid \\text{data}] = \\frac{2\\ell}{d} \\cdot \\frac{\\alpha + \\beta + N}{\\alpha + S} $$","title":"4. Bayesian Refinement of \u03c0 Estimates"},{"location":"1%20Physics/6%20Statistics/Problem_2/#advantages","text":"Produces credible intervals rather than just point estimates Handles small \\(N\\) robustly Can incorporate prior knowledge (e.g., we believe \\(\\pi \\in (3, 3.2)\\) )","title":"Advantages:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#summary-table","text":"Enhancement Type Description Implications Cross-Domain Monte Carlo Connection to physics, finance Deepens understanding, extends utility Unified Framework Indicator-based probability estimation Allows comparative analysis of methods Floating-Point Model Error decomposition into sampling and machine error Guides implementation-level accuracy Bayesian Refinement Beta-binomial model for posterior \\(\\pi\\) Offers uncertainty quantification","title":"Summary Table"},{"location":"1%20Physics/6%20Statistics/Problem_2/#conclusion_2","text":"By embedding Circle-Based and Buffon\u2019s Needle methods into the broader landscape of probabilistic modeling, we reveal deep connections to other domains and improve practical implementation. Bayesian and numerical models offer robust tools to quantify and reduce uncertainty \u2014 turning classical thought experiments into modern statistical machinery.","title":"Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_2/#code-and-plots","text":"import numpy as np import matplotlib.pyplot as plt # Set number of random points N = 10000 # Generate random points in [-1, 1] x [-1, 1] x = np.random.uniform(-1, 1, N) y = np.random.uniform(-1, 1, N) # Compute distances from origin dist_sq = x**2 + y**2 inside = dist_sq <= 1 # Estimate \u03c0 pi_estimate = 4 * np.sum(inside) / N print(f\"Estimated \u03c0 with {N} points: {pi_estimate:.6f}\") # Plotting fig, ax = plt.subplots(figsize=(6, 6), dpi=120) # Plot points ax.scatter(x[inside], y[inside], color='blue', s=1, label='Inside Circle') ax.scatter(x[~inside], y[~inside], color='red', s=1, label='Outside Circle') # Circle boundary circle = plt.Circle((0, 0), 1, edgecolor='black', facecolor='none', linewidth=2) ax.add_patch(circle) # Square boundary ax.set_xlim(-1, 1) ax.set_ylim(-1, 1) ax.set_aspect('equal') ax.set_title(f\"Monte Carlo Estimation of \u03c0\\nEstimated \u03c0 \u2248 {pi_estimate:.6f}\") ax.legend(loc='lower left', markerscale=6, frameon=True) # Remove axes for clean appearance ax.axis('off') # Save high-resolution image (optional) # plt.savefig(\"monte_carlo_pi_estimate.png\", dpi=300, bbox_inches='tight') plt.show() import numpy as np import matplotlib.pyplot as plt # Parameters needle_length = 1.0 line_spacing = 2.0 num_needles = 100_000 # Large number for accuracy # Generate random needle centers and angles x_centers = np.random.uniform(0, 4 * line_spacing, num_needles) theta = np.random.uniform(0, np.pi, num_needles) # Calculate needle endpoints dx = (needle_length / 2) * np.cos(theta) x1 = x_centers - dx x2 = x_centers + dx # Robust crossing check function def check_crossings(x1, x2, line_spacing, max_x): lines = np.arange(0, max_x + line_spacing, line_spacing) crosses = np.zeros(x1.shape, dtype=bool) for line_x in lines: cond = (x1 - line_x) * (x2 - line_x) <= 0 cond &= (x1 != x2) # Exclude needles that just touch at an endpoint crosses = crosses | cond return crosses max_x = 4 * line_spacing crosses = check_crossings(x1, x2, line_spacing, max_x) num_crosses = np.sum(crosses) # Pi estimation formula pi_estimate = (2 * needle_length * num_needles) / (line_spacing * num_crosses) # Calculate standard error p_hat = num_crosses / num_needles variance = p_hat * (1 - p_hat) se_pi = (2 * needle_length) / (line_spacing * p_hat**2) * np.sqrt(variance / num_needles) print(f\"Estimated \u03c0 = {pi_estimate:.8f}\") print(f\"Standard error = \u00b1{se_pi:.8f}\") # Visualization: sample 50 needles for clarity sample_indices = np.random.choice(num_needles, 50, replace=False) x1_vis = x1[sample_indices] x2_vis = x2[sample_indices] crosses_vis = crosses[sample_indices] y_vis = np.linspace(0, 50, 50) # Plotting fig, ax = plt.subplots(figsize=(12, 6)) # Draw vertical lines for i in range(5): ax.axvline(i * line_spacing, color='black', linestyle='--', linewidth=1) # Draw needles, color-coded by crossing for i in range(50): color = 'blue' if crosses_vis[i] else 'red' ax.plot([x1_vis[i], x2_vis[i]], [y_vis[i], y_vis[i]], color=color, linewidth=2) ax.scatter([x1_vis[i], x2_vis[i]], [y_vis[i], y_vis[i]], color=color, s=20) ax.set_xlim(-1, max_x + 1) ax.set_ylim(-5, 55) ax.set_yticks([]) ax.set_title(f\"Buffon\u2019s Needle Simulation (n={num_needles})\\nEstimated \u03c0 = {pi_estimate:.8f} \u00b1 {se_pi:.8f}\", fontsize=16) ax.set_xlabel(\"Horizontal position\") plt.tight_layout() plt.show() Colab","title":"Code and Plots"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 Measurements Problem 1: Measuring Earth's Gravitational Acceleration with a Pendulum Motivation The acceleration due to gravity, denoted by \\(g\\) , is a fundamental constant that influences a wide range of physical phenomena. Accurate determination of \\(g\\) is critical for understanding gravitational interactions, designing engineering structures, and conducting high-precision experiments in physics. One classical technique for measuring \\(g\\) involves using a simple pendulum , whose oscillatory motion is governed by the local gravitational field. Task Objective : Measure the gravitational acceleration \\(g\\) using a pendulum and rigorously analyze the uncertainties associated with the experiment. This exercise emphasizes: Measurement precision Statistical treatment of data Propagation of uncertainties Scientific reporting Procedure 1. Materials String (approx. 1.0 m long) Small mass (keychain, etc.) Stopwatch or smartphone timer Ruler or measuring tape 2. Setup The pendulum was constructed by attaching a small weight to a 1.0 m long iPhone charging cable. Measure the pendulum length, denoted \\(L\\) : \\[ L = 1.000 \\, \\text{m} \\] Estimated length uncertainty due to imprecise holding point: $$ \\Delta L = 0.030 \\, \\text{m} $$ 3. Data Collection Record the time for 10 full oscillations ( \\(T_{10}\\) ) and repeat this 10 times. Measured values (seconds): Trial \\(T_{10}\\) (s) 1 19.30 2 19.78 3 19.83 4 19.43 5 19.80 6 19.82 7 19.29 8 19.30 9 19.43 10 19.77 Calculations 1. Mean and Standard Deviation Let: \\(T_{10,i}\\) = individual time measurements \\(\\bar{T}_{10}\\) = mean of the \\(T_{10}\\) values \\(s\\) = standard deviation Mean: \\[ \\bar{T}_{10} = \\frac{1}{10} \\sum_{i=1}^{10} T_{10,i} = 19.575 \\, \\text{s} \\] Standard deviation: \\[ s = \\sqrt{\\frac{1}{N-1} \\sum_{i=1}^{10} (T_{10,i} - \\bar{T}_{10})^2} \\approx 0.237 \\, \\text{s} \\] Uncertainty in mean: \\[ \\Delta \\bar{T}_{10} = \\frac{s}{\\sqrt{N}} = \\frac{0.237}{\\sqrt{10}} \\approx 0.075 \\, \\text{s} \\] 2. Period of One Oscillation \\[ T = \\frac{\\bar{T}_{10}}{10} = \\frac{19.575}{10} = 1.9575 \\, \\text{s} \\] Uncertainty in \\(T\\) : \\[ \\Delta T = \\frac{\\Delta \\bar{T}_{10}}{10} = \\frac{0.075}{10} = 0.0075 \\, \\text{s} \\] 3. Gravitational Acceleration Using the formula: \\[ g = \\frac{4\\pi^2 L}{T^2} \\] Substitute values: \\[ g = \\frac{4\\pi^2 (1.000)}{(1.9575)^2} \\approx 10.28 \\, \\text{m/s}^2 \\] 4. Uncertainty in \\(g\\) Using propagation of uncertainty: \\[ \\left( \\frac{\\Delta g}{g} \\right)^2 = \\left( \\frac{\\Delta L}{L} \\right)^2 + \\left( 2 \\cdot \\frac{\\Delta T}{T} \\right)^2 \\] Substitute: \\(\\frac{\\Delta L}{L} = \\frac{0.030}{1.000} = 0.030\\) \\(\\frac{\\Delta T}{T} = \\frac{0.0075}{1.9575} \\approx 0.0038\\) Then: \\[ \\left( \\frac{\\Delta g}{g} \\right)^2 = (0.030)^2 + (2 \\cdot 0.0038)^2 = 0.0009 + 0.000058 = 0.000958 \\] So: \\[ \\Delta g = g \\cdot \\sqrt{0.000958} \\approx 10.28 \\cdot 0.03095 \\approx 0.318 \\, \\text{m/s}^2 \\] Final Result \\[ g = (10.28 \\pm 0.32) \\, \\text{m/s}^2 \\] Analysis and Discussion 1. Comparison to Standard Value Standard value: \\[ g_{\\text{standard}} = 9.81 \\, \\text{m/s}^2 \\] Difference: \\[ \\Delta g = 10.28 - 9.81 = 0.47 \\, \\text{m/s}^2 \\] While the measured value is higher, it now falls within the expanded uncertainty margin , indicating the result is not statistically inconsistent with the accepted value. 2. Discussion Points Length uncertainty dominates : The \u00b13 cm uncertainty in \\(L\\) is the primary contributor to error in \\(g\\) . Measuring the pivot point more carefully would significantly improve accuracy. Timing uncertainty : Still present due to human reaction time, but less impactful than length uncertainty. Experimental simplifications : Assumptions such as small-angle oscillation and negligible air resistance may still introduce slight systematic deviations. Improvement suggestions : Use a fixed retort stand, laser timing, and a more rigid string or rod. Deliverables Measured Data : \\(L = 1.000 \\pm 0.030 \\, \\text{m}\\) \\(T = 1.9575 \\pm 0.0075 \\, \\text{s}\\) Calculated Result : $$ g = (10.28 \\pm 0.32) \\, \\text{m/s}^2 $$ Table of Measurements : (see data collection) Uncertainty analysis : (see calculations and discussion) Code and Plots # Pendulum Measurement Analysis with Visualization import numpy as np import matplotlib.pyplot as plt # === DATA === L = 1.000 # Length in meters delta_L = 0.030 # Uncertainty in length (3 cm) T10_data = np.array([19.30, 19.78, 19.83, 19.43, 19.80, 19.82, 19.29, 19.30, 19.43, 19.77]) # Time for 10 oscillations g_standard = 9.81 # Standard g value in m/s\u00b2 # === ANALYSIS === T10_mean = np.mean(T10_data) T10_std = np.std(T10_data, ddof=1) delta_T10_mean = T10_std / np.sqrt(len(T10_data)) T = T10_mean / 10 delta_T = delta_T10_mean / 10 g = (4 * np.pi**2 * L) / (T**2) rel_delta_L = delta_L / L rel_delta_T = delta_T / T rel_delta_g = np.sqrt(rel_delta_L**2 + (2 * rel_delta_T)**2) delta_g = g * rel_delta_g # === PRINT RESULTS === print(\"---- Experimental Results ----\") print(f\"Mean time for 10 oscillations: {T10_mean:.4f} s \u00b1 {delta_T10_mean:.4f} s\") print(f\"Period of one oscillation: {T:.4f} s \u00b1 {delta_T:.4f} s\") print(f\"Pendulum length: {L:.3f} m \u00b1 {delta_L:.3f} m\") print(f\"Calculated g: {g:.2f} m/s\u00b2 \u00b1 {delta_g:.2f} m/s\u00b2\") print(f\"Standard g: {g_standard:.2f} m/s\u00b2\") print(f\"Difference: {abs(g - g_standard):.2f} m/s\u00b2\") # === PLOT 1: g comparison with error bar === plt.figure(figsize=(6, 5)) plt.errorbar(1, g, yerr=delta_g, fmt='o', capsize=10, label='Measured g', color='blue') plt.hlines(g_standard, 0.5, 1.5, colors='red', linestyles='--', label='Standard g') plt.xticks([1], ['Gravitational Acceleration']) plt.ylabel(\"g (m/s\u00b2)\") plt.title(\"Measured vs Standard Gravitational Acceleration\") plt.legend() plt.grid(True) plt.ylim(min(g - delta_g - 0.5, g_standard - 0.5), max(g + delta_g + 0.5, g_standard + 0.5)) plt.show() # === PLOT 2: Raw T10 measurements === plt.figure(figsize=(8, 4)) plt.plot(range(1, 11), T10_data, marker='o', linestyle='-', color='darkgreen') plt.axhline(T10_mean, color='gray', linestyle='--', label='Mean T\u2081\u2080') plt.fill_between(range(1, 11), T10_mean - T10_std, T10_mean + T10_std, color='gray', alpha=0.2, label='\u00b11\u03c3 range') plt.xlabel(\"Trial Number\") plt.ylabel(\"Time for 10 Oscillations (s)\") plt.title(\"Raw Timing Data\") plt.legend() plt.grid(True) plt.show() Colab","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#measurements","text":"","title":"Measurements"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1-measuring-earths-gravitational-acceleration-with-a-pendulum","text":"","title":"Problem 1: Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#motivation","text":"The acceleration due to gravity, denoted by \\(g\\) , is a fundamental constant that influences a wide range of physical phenomena. Accurate determination of \\(g\\) is critical for understanding gravitational interactions, designing engineering structures, and conducting high-precision experiments in physics. One classical technique for measuring \\(g\\) involves using a simple pendulum , whose oscillatory motion is governed by the local gravitational field.","title":"Motivation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#task","text":"Objective : Measure the gravitational acceleration \\(g\\) using a pendulum and rigorously analyze the uncertainties associated with the experiment. This exercise emphasizes: Measurement precision Statistical treatment of data Propagation of uncertainties Scientific reporting","title":"Task"},{"location":"1%20Physics/7%20Measurements/Problem_1/#procedure","text":"","title":"Procedure"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-materials","text":"String (approx. 1.0 m long) Small mass (keychain, etc.) Stopwatch or smartphone timer Ruler or measuring tape","title":"1. Materials"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-setup","text":"The pendulum was constructed by attaching a small weight to a 1.0 m long iPhone charging cable. Measure the pendulum length, denoted \\(L\\) : \\[ L = 1.000 \\, \\text{m} \\] Estimated length uncertainty due to imprecise holding point: $$ \\Delta L = 0.030 \\, \\text{m} $$","title":"2. Setup"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-data-collection","text":"Record the time for 10 full oscillations ( \\(T_{10}\\) ) and repeat this 10 times. Measured values (seconds): Trial \\(T_{10}\\) (s) 1 19.30 2 19.78 3 19.83 4 19.43 5 19.80 6 19.82 7 19.29 8 19.30 9 19.43 10 19.77","title":"3. Data Collection"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculations","text":"","title":"Calculations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-mean-and-standard-deviation","text":"Let: \\(T_{10,i}\\) = individual time measurements \\(\\bar{T}_{10}\\) = mean of the \\(T_{10}\\) values \\(s\\) = standard deviation Mean: \\[ \\bar{T}_{10} = \\frac{1}{10} \\sum_{i=1}^{10} T_{10,i} = 19.575 \\, \\text{s} \\] Standard deviation: \\[ s = \\sqrt{\\frac{1}{N-1} \\sum_{i=1}^{10} (T_{10,i} - \\bar{T}_{10})^2} \\approx 0.237 \\, \\text{s} \\] Uncertainty in mean: \\[ \\Delta \\bar{T}_{10} = \\frac{s}{\\sqrt{N}} = \\frac{0.237}{\\sqrt{10}} \\approx 0.075 \\, \\text{s} \\]","title":"1. Mean and Standard Deviation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-period-of-one-oscillation","text":"\\[ T = \\frac{\\bar{T}_{10}}{10} = \\frac{19.575}{10} = 1.9575 \\, \\text{s} \\] Uncertainty in \\(T\\) : \\[ \\Delta T = \\frac{\\Delta \\bar{T}_{10}}{10} = \\frac{0.075}{10} = 0.0075 \\, \\text{s} \\]","title":"2. Period of One Oscillation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-gravitational-acceleration","text":"Using the formula: \\[ g = \\frac{4\\pi^2 L}{T^2} \\] Substitute values: \\[ g = \\frac{4\\pi^2 (1.000)}{(1.9575)^2} \\approx 10.28 \\, \\text{m/s}^2 \\]","title":"3. Gravitational Acceleration"},{"location":"1%20Physics/7%20Measurements/Problem_1/#4-uncertainty-in-g","text":"Using propagation of uncertainty: \\[ \\left( \\frac{\\Delta g}{g} \\right)^2 = \\left( \\frac{\\Delta L}{L} \\right)^2 + \\left( 2 \\cdot \\frac{\\Delta T}{T} \\right)^2 \\] Substitute: \\(\\frac{\\Delta L}{L} = \\frac{0.030}{1.000} = 0.030\\) \\(\\frac{\\Delta T}{T} = \\frac{0.0075}{1.9575} \\approx 0.0038\\) Then: \\[ \\left( \\frac{\\Delta g}{g} \\right)^2 = (0.030)^2 + (2 \\cdot 0.0038)^2 = 0.0009 + 0.000058 = 0.000958 \\] So: \\[ \\Delta g = g \\cdot \\sqrt{0.000958} \\approx 10.28 \\cdot 0.03095 \\approx 0.318 \\, \\text{m/s}^2 \\]","title":"4. Uncertainty in \\(g\\)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#final-result","text":"\\[ g = (10.28 \\pm 0.32) \\, \\text{m/s}^2 \\]","title":"Final Result"},{"location":"1%20Physics/7%20Measurements/Problem_1/#analysis-and-discussion","text":"","title":"Analysis and Discussion"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-comparison-to-standard-value","text":"Standard value: \\[ g_{\\text{standard}} = 9.81 \\, \\text{m/s}^2 \\] Difference: \\[ \\Delta g = 10.28 - 9.81 = 0.47 \\, \\text{m/s}^2 \\] While the measured value is higher, it now falls within the expanded uncertainty margin , indicating the result is not statistically inconsistent with the accepted value.","title":"1. Comparison to Standard Value"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-discussion-points","text":"Length uncertainty dominates : The \u00b13 cm uncertainty in \\(L\\) is the primary contributor to error in \\(g\\) . Measuring the pivot point more carefully would significantly improve accuracy. Timing uncertainty : Still present due to human reaction time, but less impactful than length uncertainty. Experimental simplifications : Assumptions such as small-angle oscillation and negligible air resistance may still introduce slight systematic deviations. Improvement suggestions : Use a fixed retort stand, laser timing, and a more rigid string or rod.","title":"2. Discussion Points"},{"location":"1%20Physics/7%20Measurements/Problem_1/#deliverables","text":"Measured Data : \\(L = 1.000 \\pm 0.030 \\, \\text{m}\\) \\(T = 1.9575 \\pm 0.0075 \\, \\text{s}\\) Calculated Result : $$ g = (10.28 \\pm 0.32) \\, \\text{m/s}^2 $$ Table of Measurements : (see data collection) Uncertainty analysis : (see calculations and discussion)","title":"Deliverables"},{"location":"1%20Physics/7%20Measurements/Problem_1/#code-and-plots","text":"# Pendulum Measurement Analysis with Visualization import numpy as np import matplotlib.pyplot as plt # === DATA === L = 1.000 # Length in meters delta_L = 0.030 # Uncertainty in length (3 cm) T10_data = np.array([19.30, 19.78, 19.83, 19.43, 19.80, 19.82, 19.29, 19.30, 19.43, 19.77]) # Time for 10 oscillations g_standard = 9.81 # Standard g value in m/s\u00b2 # === ANALYSIS === T10_mean = np.mean(T10_data) T10_std = np.std(T10_data, ddof=1) delta_T10_mean = T10_std / np.sqrt(len(T10_data)) T = T10_mean / 10 delta_T = delta_T10_mean / 10 g = (4 * np.pi**2 * L) / (T**2) rel_delta_L = delta_L / L rel_delta_T = delta_T / T rel_delta_g = np.sqrt(rel_delta_L**2 + (2 * rel_delta_T)**2) delta_g = g * rel_delta_g # === PRINT RESULTS === print(\"---- Experimental Results ----\") print(f\"Mean time for 10 oscillations: {T10_mean:.4f} s \u00b1 {delta_T10_mean:.4f} s\") print(f\"Period of one oscillation: {T:.4f} s \u00b1 {delta_T:.4f} s\") print(f\"Pendulum length: {L:.3f} m \u00b1 {delta_L:.3f} m\") print(f\"Calculated g: {g:.2f} m/s\u00b2 \u00b1 {delta_g:.2f} m/s\u00b2\") print(f\"Standard g: {g_standard:.2f} m/s\u00b2\") print(f\"Difference: {abs(g - g_standard):.2f} m/s\u00b2\") # === PLOT 1: g comparison with error bar === plt.figure(figsize=(6, 5)) plt.errorbar(1, g, yerr=delta_g, fmt='o', capsize=10, label='Measured g', color='blue') plt.hlines(g_standard, 0.5, 1.5, colors='red', linestyles='--', label='Standard g') plt.xticks([1], ['Gravitational Acceleration']) plt.ylabel(\"g (m/s\u00b2)\") plt.title(\"Measured vs Standard Gravitational Acceleration\") plt.legend() plt.grid(True) plt.ylim(min(g - delta_g - 0.5, g_standard - 0.5), max(g + delta_g + 0.5, g_standard + 0.5)) plt.show() # === PLOT 2: Raw T10 measurements === plt.figure(figsize=(8, 4)) plt.plot(range(1, 11), T10_data, marker='o', linestyle='-', color='darkgreen') plt.axhline(T10_mean, color='gray', linestyle='--', label='Mean T\u2081\u2080') plt.fill_between(range(1, 11), T10_mean - T10_std, T10_mean + T10_std, color='gray', alpha=0.2, label='\u00b11\u03c3 range') plt.xlabel(\"Trial Number\") plt.ylabel(\"Time for 10 Oscillations (s)\") plt.title(\"Raw Timing Data\") plt.legend() plt.grid(True) plt.show() Colab","title":"Code and Plots"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}